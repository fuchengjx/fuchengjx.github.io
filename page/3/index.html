<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.flura.cn","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="flura的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="flura的博客">
<meta property="og:url" content="http://www.flura.cn/page/3/index.html">
<meta property="og:site_name" content="flura的博客">
<meta property="og:description" content="flura的个人博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="flura">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.flura.cn/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>flura的博客</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Y3KRTGH4W2"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-Y3KRTGH4W2');
      }
    </script>


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d538b50de2cb47eab83d95694995ab95";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">flura的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">34</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/07/12/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
      <script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/12/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/" class="post-title-link" itemprop="url">TypeScript学习笔记(二)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-12 20:28:03" itemprop="dateCreated datePublished" datetime="2019-07-12T20:28:03+08:00">2019-07-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
                </span>
            </span>

          
            <span id="/2019/07/12/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/" class="post-meta-item leancloud_visitors" data-flag-title="TypeScript学习笔记(二)" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2019/07/12/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/07/12/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>TypeScript的核心原则之一是对值所具有的<em>结构</em>进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
<h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><p>在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。</p>
<p>TypeScript 中的接口是一个非常灵活的概念，除了可用于<a target="_blank" rel="noopener" href="https://github.com/xcatliu/typescript-tutorial/blob/master/advanced/class-and-interfaces.md#%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3">对类的一部分行为进行抽象</a>以外，也常用于对「对象的形状（Shape）」进行描述。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tom: Person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Tom&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">25</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//我们定义了一个接口 Person，接着定义了一个变量 tom，它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致。</span></span><br></pre></td></tr></table></figure>

<p>定义的变量比接口少了一些属性是不允许的。多一些属性也是不允许的。可见，<strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong>。</p>
<h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>有时我们希望不要完全匹配一个形状，那么可以用可选属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可选属性的含义是该属性可以不存在。这时<strong>仍然不允许添加未定义的属性</strong>。</p>
<h2 id="任意属性"><a href="#任意属性" class="headerlink" title="任意属性"></a>任意属性</h2><p>有时候我们希望一个接口允许有任意的属性，可以使用如下方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用 <code>[propName: string]</code> 定义了任意属性取 <code>string</code> 类型的值。</p>
<p>需要注意的是，<strong>一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    age: 25,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// index.ts(3,5): error TS2411: Property &#x27;age&#x27; of type &#x27;number&#x27; is not assignable to string index type &#x27;string&#x27;.</span><br><span class="line">// index.ts(7,5): error TS2322: Type &#x27;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="line">//   Index signatures are incompatible.</span><br><span class="line">//     Type &#x27;string | number&#x27; is not assignable to type &#x27;string&#x27;.</span><br><span class="line">//       Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span><br></pre></td></tr></table></figure>

<p>上例中，任意属性的值允许是 <code>string</code>，但是可选属性 <code>age</code> 的值却是 <code>number</code>，<code>number</code> 不是 <code>string</code> 的子属性，所以报错了。</p>
<p>另外，在报错信息中可以看出，此时 <code>&#123; name: &#39;Tom&#39;, age: 25, gender: &#39;male&#39; &#125;</code> 的类型被推断成了 <code>&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;</code>，这是联合类型和接口的结合。</p>
<h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 <code>readonly</code>定义只读属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    readonly id: number;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    id: 89757,</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = 9527;</span><br><span class="line"></span><br><span class="line">// index.ts(14,5): error TS2540: Cannot assign to &#x27;id&#x27; because it is a constant or a read-only property.</span><br></pre></td></tr></table></figure>

<p>上例中，使用 <code>readonly</code> 定义的属性 <code>id</code> 初始化后，又被赋值了，所以报错了。</p>
<p><strong>注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">interface Person &#123;</span><br><span class="line">    readonly id: number;</span><br><span class="line">    name: string;</span><br><span class="line">    age?: number;</span><br><span class="line">    [propName: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let tom: Person = &#123;</span><br><span class="line">    name: &#x27;Tom&#x27;,</span><br><span class="line">    gender: &#x27;male&#x27;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">tom.id = 89757;</span><br><span class="line"></span><br><span class="line">// index.ts(8,5): error TS2322: Type &#x27;&#123; name: string; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.</span><br><span class="line">//   Property &#x27;id&#x27; is missing in type &#x27;&#123; name: string; gender: string; &#125;&#x27;.</span><br><span class="line">// index.ts(13,5): error TS2540: Cannot assign to &#x27;id&#x27; because it is a constant or a read-only property.</span><br></pre></td></tr></table></figure>

<p>上例中，报错信息有两处，第一处是在对 <code>tom</code> 进行赋值的时候，没有给 <code>id</code> 赋值。</p>
<p>第二处是在给 <code>tom.id</code> 赋值的时候，由于它是只读属性，所以报错了。</p>
<h1 id="数组的类型"><a href="#数组的类型" class="headerlink" title="数组的类型"></a>数组的类型</h1><p>在 TypeScript 中，数组类型有多种定义方式，比较灵活。</p>
<h2 id="「类型-方括号」表示法"><a href="#「类型-方括号」表示法" class="headerlink" title="「类型 + 方括号」表示法"></a>「类型 + 方括号」表示法</h2><p>最简单的方法是使用「类型 + 方括号」来表示数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: number[] = [1, 1, 2, 3, 5];</span><br></pre></td></tr></table></figure>

<p>数组的项中<strong>不允许</strong>出现其他的类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: number[] = [1, &#x27;1&#x27;, 2, 3, 5];</span><br><span class="line"></span><br><span class="line">// index.ts(1,5): error TS2322: Type &#x27;(number | string)[]&#x27; is not assignable to type &#x27;number[]&#x27;.</span><br><span class="line">//   Type &#x27;number | string&#x27; is not assignable to type &#x27;number&#x27;.</span><br><span class="line">//     Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<p>上例中，<code>[1, &#39;1&#39;, 2, 3, 5]</code> 的类型被推断为 <code>(number | string)[]</code>，这是联合类型和数组的结合。</p>
<p>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: number[] = [1, 1, 2, 3, 5];</span><br><span class="line">fibonacci.push(&#x27;8&#x27;);</span><br><span class="line"></span><br><span class="line">// index.ts(2,16): error TS2345: Argument of type &#x27;string&#x27; is not assignable to parameter of type &#x27;number&#x27;.</span><br></pre></td></tr></table></figure>

<p>上例中，<code>push</code> 方法只允许传入 <code>number</code> 类型的参数，但是却传了一个 <code>string</code> 类型的参数，所以报错了。</p>
<h2 id="数组泛型"><a href="#数组泛型" class="headerlink" title="数组泛型"></a>数组泛型</h2><p>也可以使用数组泛型（Array Generic） <code>Array&lt;elemType&gt;</code> 来表示数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];</span><br></pre></td></tr></table></figure>

<h2 id="用接口表示数组"><a href="#用接口表示数组" class="headerlink" title="用接口表示数组"></a>用接口表示数组</h2><p>接口也可以用来描述数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface NumberArray &#123;</span><br><span class="line">    [index: number]: number;</span><br><span class="line">&#125;</span><br><span class="line">let fibonacci: NumberArray = [1, 1, 2, 3, 5];</span><br></pre></td></tr></table></figure>

<p><code>NumberArray</code> 表示：只要 <code>index</code> 的类型是 <code>number</code>，那么值的类型必须是 <code>number</code>。</p>
<h2 id="any-在数组中的应用"><a href="#any-在数组中的应用" class="headerlink" title="any 在数组中的应用"></a>any 在数组中的应用</h2><p>一个比较常见的做法是，用 <code>any</code> 表示数组中允许出现任意类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let list: any[] = [&#x27;Xcat Liu&#x27;, 25, &#123; website: &#x27;http://xcatliu.com&#x27; &#125;];</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">    let args: IArguments = arguments;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/07/11/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
      <script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/11/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/" class="post-title-link" itemprop="url">TypeScript学习笔记(一)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-11 20:46:49" itemprop="dateCreated datePublished" datetime="2019-07-11T20:46:49+08:00">2019-07-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
                </span>
            </span>

          
            <span id="/2019/07/11/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/" class="post-meta-item leancloud_visitors" data-flag-title="TypeScript学习笔记(一)" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2019/07/11/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/07/11/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>什么是TS，TS的优点 为什么选择TS。 TypeScript里的基础类型、任意值、联合类型等。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/07/11/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/07/09/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
      <script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/09/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">react学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-09 10:46:41" itemprop="dateCreated datePublished" datetime="2019-07-09T10:46:41+08:00">2019-07-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
                </span>
            </span>

          
            <span id="/2019/07/09/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="react学习笔记" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2019/07/09/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/07/09/react%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="React-介绍"><a href="#React-介绍" class="headerlink" title="React 介绍"></a>React 介绍</h2><ul>
<li>React 是一个用于构建用户界面的渐进式 JavaScript 库<ul>
<li>本身只处理 UI</li>
<li>不关系路由</li>
<li>不处理 ajax</li>
</ul>
</li>
<li>React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。<ul>
<li>数据驱动视图</li>
</ul>
</li>
<li>React 由 Facebook 开发</li>
<li>第一个真生意义上把组件化思想待到前端开发领域</li>
</ul>
<h3 id="React-特点"><a href="#React-特点" class="headerlink" title="React 特点"></a>React 特点</h3><ul>
<li>组件化</li>
<li>高效<ul>
<li>虚拟 DOM</li>
<li>Vue 2 也是虚拟 DOM</li>
<li>虚拟 DOM 更高效</li>
</ul>
</li>
<li>灵活<ul>
<li>渐进式，本身只处理 UI ，可以和你的其它技术栈组合到一起来使用</li>
</ul>
</li>
<li>声明（配置）式设计<ul>
<li><code>data</code> 响应式数据</li>
<li><code>mathods</code> 处理函数</li>
<li>这样做的好处就是按照我们约定好的方式来开发，所有人写出来的代码就像一个人写的</li>
<li><code>state</code></li>
<li>方法就是类成员</li>
<li>也有特定的组件生命钩子</li>
</ul>
</li>
<li>JSX<ul>
<li>一种预编译 JavaScript 语言，允许让你的 JavaScript 和 HTML 混搭</li>
<li>模板中就是 JavaScript 逻辑</li>
</ul>
</li>
<li>单向数据流<ul>
<li>组件传值</li>
<li>所有数据都是单向的，组件传递的数据都是单向</li>
<li>Vue 也是单向数据流</li>
<li>没有双向数据绑定</li>
</ul>
</li>
</ul>
<h3 id="React-与-Vue-的对比"><a href="#React-与-Vue-的对比" class="headerlink" title="React 与 Vue 的对比"></a>React 与 Vue 的对比</h3><h4 id="技术层面"><a href="#技术层面" class="headerlink" title="技术层面"></a>技术层面</h4><ul>
<li>Vue 生产力更高（更少的代码实现更强劲的功能）</li>
<li>React 更 hack 技术占比比较重</li>
<li>两个框架的效率都采用了虚拟 DOM<ul>
<li>性能都差不多</li>
</ul>
</li>
<li>组件化<ul>
<li>Vue 支持</li>
<li>React 支持</li>
</ul>
</li>
<li>数据绑定<ul>
<li>都支持数据驱动视图</li>
<li>Vue 支持表单控件双向数据绑定</li>
<li>React 不支持双向数据绑定</li>
</ul>
</li>
<li>它们的核心库都很小，都是渐进式 JavaScript 库</li>
<li>React 采用 JSX 语法来编写组件</li>
<li>Vue 采用单文件组件<ul>
<li><code>template</code></li>
<li><code>script</code></li>
<li><code>style</code></li>
</ul>
</li>
</ul>
<h4 id="开发团队"><a href="#开发团队" class="headerlink" title="开发团队"></a>开发团队</h4><ul>
<li>React 由 Facebook 前端维护开发</li>
<li>Vue<ul>
<li>早期只有尤雨溪一个人</li>
<li>由于后来使用者越来越多，后来离职专职开发维护</li>
<li>目前也有一个小团队在开发维护</li>
</ul>
</li>
</ul>
<h4 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h4><ul>
<li>React 社区比 Vue 更强大</li>
<li>Vue 社区也很强大</li>
</ul>
<h4 id="Native-APP-开发"><a href="#Native-APP-开发" class="headerlink" title="Native APP 开发"></a>Native APP 开发</h4><ul>
<li>React Native<ul>
<li>可以原生应用</li>
<li>React 结束之后会学习</li>
</ul>
</li>
<li>Weex<ul>
<li>阿里巴巴内部搞出来的一个东西，基于 Vue</li>
</ul>
</li>
</ul>
<h3 id="相关资源链接"><a href="#相关资源链接" class="headerlink" title="相关资源链接"></a>相关资源链接</h3><ul>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/">React 官网</a></li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/tutorial/tutorial.html">官方教程</a><ul>
<li>连字游戏</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://reactjs.org/docs/">官方文档</a><ul>
<li>基础教程</li>
<li>高级教程</li>
<li>API 参考文档</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/react">React - GitHub</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/09/react-technology-stack.html">阮一峰 - React 技术栈系列教程</a></li>
<li>[阮一峰 - React 入门实例教程]（<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/03/react.html">http://www.ruanyifeng.com/blog/2015/03/react.html</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/enaqx/awesome-react">awesome react</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/brillout/awesome-react-components">awesome-react-components</a></li>
</ul>
<h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://reactjs.org/docs/hello-world.html">https://reactjs.org/docs/hello-world.html</a></p>
</blockquote>
<h3 id="初始化及安装依赖"><a href="#初始化及安装依赖" class="headerlink" title="初始化及安装依赖"></a>初始化及安装依赖</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir react-demos</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> react-demos</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm init --yes</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install --save babel-standalone react react-dom</span></span><br></pre></td></tr></table></figure>

<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>demo - Hello World<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../node_modules/babel-standalone/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../node_modules/react/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../node_modules/react-dom/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    ReactDOM.render(</span></span><br><span class="line"><span class="javascript">      <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, react!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    )</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>HTML 语言直接写在 JavaScript 语言中，不加任何引号，这就是 JSX 语法。它允许 HTML 与 JavaScript 的混写。</p>
<h3 id="基本语法规则"><a href="#基本语法规则" class="headerlink" title="基本语法规则"></a>基本语法规则</h3><ul>
<li><p><strong>必须只能有一个根节点</strong></p>
</li>
<li><p>遇到 HTML 标签 （以 <code>&lt;</code> 开头） 就用 HTML 规则解析</p>
<ul>
<li>单标签不能省略结束标签。</li>
</ul>
</li>
<li><p>遇到代码块（以 <code>&#123;</code> 开头），就用 JavaScript 规则解析</p>
</li>
<li><p>JSX 允许直接在模板中插入一个 JavaScript 变量</p>
<ul>
<li>如果这个变量是一个数组，则会展开这个数组的所有成员添加到模板中</li>
</ul>
</li>
<li><p>单标签必须结束 <code>/&gt;</code></p>
</li>
</ul>
<h3 id="在-JSX-中嵌入-JavaScript-表达式"><a href="#在-JSX-中嵌入-JavaScript-表达式" class="headerlink" title="在 JSX 中嵌入 JavaScript 表达式"></a>在 JSX 中嵌入 JavaScript 表达式</h3><ul>
<li>语法</li>
<li>如果 JSX 写到了多行中，则建议包装括号避免自动分号的陷阱</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> user.firstName + <span class="string">&#x27; &#x27;</span> + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;Harper&#x27;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&#x27;Perez&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    Hello, &#123;formatName(user)&#125;!</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="在-JavaScript-表达式中嵌入-JSX"><a href="#在-JavaScript-表达式中嵌入-JSX" class="headerlink" title="在 JavaScript 表达式中嵌入 JSX"></a>在 JavaScript 表达式中嵌入 JSX</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JSX-中的节点属性"><a href="#JSX-中的节点属性" class="headerlink" title="JSX 中的节点属性"></a>JSX 中的节点属性</h3><ul>
<li>动态绑定属性值</li>
<li><code>class</code> 使用 <code>className</code></li>
<li><code>tabindex</code> 使用 <code>tabIndex</code></li>
<li><code>for</code> 使用 <code>htmlFor</code></li>
</ul>
<p>普通的属性：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">tabIndex</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<p>在属性中使用表达式：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="声明子节点"><a href="#声明子节点" class="headerlink" title="声明子节点"></a>声明子节点</h3><p>如果标签是空的，可以使用 <code>/&gt;</code> 立即关闭它。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<p>JSX 子节点可以包含子节点：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Good to see you here.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="JSX-自动阻止注入攻击"><a href="#JSX-自动阻止注入攻击" class="headerlink" title="JSX 自动阻止注入攻击"></a>JSX 自动阻止注入攻击</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#x27;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>this is safe<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#x27;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="在-JSX-中使用注释"><a href="#在-JSX-中使用注释" class="headerlink" title="在 JSX 中使用注释"></a>在 JSX 中使用注释</h3><p>写法一：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 注释</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写法二（单行推荐）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;/* 单行注释 */&#125;</span><br></pre></td></tr></table></figure>

<p>写法三（多行推荐）：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 多行注释</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="JSX-原理"><a href="#JSX-原理" class="headerlink" title="JSX 原理"></a>JSX 原理</h3><p>Babel 会把 JSX 编译为 <code>React.createElement()</code> 函数。</p>
<p>实际上，JSX 仅仅只是 <code>React.createElement(component, props, ...children)</code> 函数的语法糖。如下 JSX 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyButton color=&quot;blue&quot; shadowSize=&#123;2&#125;&gt;</span><br><span class="line">  Click Me</span><br><span class="line">&lt;/MyButton&gt;</span><br></pre></td></tr></table></figure>

<p>会编译为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  MyButton,</span><br><span class="line">  &#123;color: &#x27;blue&#x27;, shadowSize: 2&#125;,</span><br><span class="line">  &#x27;Click Me&#x27;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<ul>
<li>每个 React 元素都是一个真实的 JavaScript 对象</li>
</ul>
<p>下面两种方式是等价的：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;greeting&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    Hello, world!</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">&#x27;greeting&#x27;</span>&#125;,</span><br><span class="line">  <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: this structure is simplified</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">className</span>: <span class="string">&#x27;greeting&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;Hello, world&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h2 id="列表循环"><a href="#列表循环" class="headerlink" title="列表循环"></a>列表循环</h2><p>JSX 允许直接在模板插入 JavaScript 变量。如果这个变量是一个数组，则会展开这个数组的所有成员。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>React is awesome<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>,</span><br><span class="line">];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;arr&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>综上所述，我们可以这样：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Emily&#x27;</span>, <span class="string">&#x27;Kate&#x27;</span>];</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  &#123;</span></span><br><span class="line"><span class="xml">    names.map(function (name) &#123;</span></span><br><span class="line"><span class="xml">      return <span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, &#123;name&#125;!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>





<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function WarningBanner(props) &#123;</span><br><span class="line">  if (!props.warn) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;warning&quot;&gt;</span><br><span class="line">      Warning!</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Page extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;showWarning: true&#125;</span><br><span class="line">    this.handleToggleClick = this.handleToggleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleToggleClick() &#123;</span><br><span class="line">    this.setState(prevState =&gt; (&#123;</span><br><span class="line">      showWarning: !prevState.showWarning</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;WarningBanner warn=&#123;this.state.showWarning&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleToggleClick&#125;&gt;</span><br><span class="line">          &#123;this.state.showWarning ? &#x27;Hide&#x27; : &#x27;Show&#x27;&#125;</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Page /&gt;,</span><br><span class="line">  document.getElementById(&#x27;root&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function ActionLink() &#123;</span><br><span class="line">  function handleClick(e) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    console.log(&#x27;The link was clicked.&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;a href=&quot;#&quot; onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Toggle extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;isToggleOn: true&#125;;</span><br><span class="line"></span><br><span class="line">​```</span><br><span class="line">// This binding is necessary to make `this` work in the callback</span><br><span class="line">this.handleClick = this.handleClick.bind(this);</span><br><span class="line">​```</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    this.setState(prevState =&gt; (&#123;</span><br><span class="line">      isToggleOn: !prevState.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">        &#123;this.state.isToggleOn ? &#x27;ON&#x27; : &#x27;OFF&#x27;&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Toggle /&gt;,</span><br><span class="line">  document.getElementById(&#x27;root&#x27;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>React 允许将代码封装成组件（component），然后像插入普通 HTML 标签一样，在网页中插入这个组件。</p>
<h3 id="组件规则注意事项"><a href="#组件规则注意事项" class="headerlink" title="组件规则注意事项"></a>组件规则注意事项</h3><ul>
<li><strong>组件类的第一个首字母必须大写</strong></li>
<li>组件类必须有 <code>render</code> 方法</li>
<li>组件类必须有且只有一个根节点</li>
<li>组件属性可以在组件的 <code>props</code> 获取<ul>
<li>函数需要声明参数：<code>props</code></li>
<li>类直接通过 <code>this.props</code></li>
</ul>
</li>
</ul>
<h3 id="函数式组件（无状态）"><a href="#函数式组件（无状态）" class="headerlink" title="函数式组件（无状态）"></a>函数式组件（无状态）</h3><ul>
<li>名字不能用小写<ul>
<li>React 在解析的时候，是以标签的首字母来区分的</li>
<li>如果首字母是小写则当作 HTML 来解析</li>
<li>如果首字母是大小则当作组件来解析</li>
<li>结论：组件首字母必须大写</li>
</ul>
</li>
</ul>
<h3 id="类方式组件（有状态）"><a href="#类方式组件（有状态）" class="headerlink" title="类方式组件（有状态）"></a>类方式组件（有状态）</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShoppingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;shopping-list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Shopping List for &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>Instagram<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>WhatsApp<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>Oculus<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example usage: &lt;ShoppingList name=&quot;Mark&quot; /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="组件传值-Props"><a href="#组件传值-Props" class="headerlink" title="组件传值 Props"></a>组件传值 Props</h3><p>EcmaScript 5 构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>EcmaScript 6 Class：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this-props-children"><a href="#this-props-children" class="headerlink" title="this.props.children"></a><code>this.props.children</code></h3><blockquote>
<p>参考文档：<a target="_blank" rel="noopener" href="https://reactjs.org/docs/react-api.html#reactchildren">https://reactjs.org/docs/react-api.html#reactchildren</a></p>
</blockquote>
<p><code>this.props</code> 对象的属性与组件的属性一一对应，但是有一个例外，就是 <code>this.props.children</code> 属性。</p>
<p>它表示组件的所有子节点。</p>
<p><code>this.props.children</code> 的值有三种可能：如果当前组件没有子节点，它就是 <code>undefined</code>;如果有一个子节点，数据类型是 <code>object</code> ；如果有多个子节点，数据类型就是 <code>array</code> 。所以，处理 <code>this.props.children</code> 的时候要小心。</p>
<p>React 提供一个工具方法 <a target="_blank" rel="noopener" href="https://facebook.github.io/react/docs/top-level-api.html#react.children"><code>React.Children</code></a> 来处理 <code>this.props.children</code> 。我们可以用 <code>React.Children.map</code> 来遍历子节点，而不用担心 <code>this.props.children</code> 的数据类型是 <code>undefined</code> 还是 <code>object</code>。</p>
<h3 id="用户定义的组件必须以大写字母开头"><a href="#用户定义的组件必须以大写字母开头" class="headerlink" title="用户定义的组件必须以大写字母开头"></a>用户定义的组件必须以大写字母开头</h3><p><strong>以小写字母开头的元素代表一个 HTML 内置组件</strong>，比如 <code>&lt;div&gt;</code> 或者 <code>&lt;span&gt;</code> 会生成相应的字符串 <code>&#39;div&#39;</code> 或者 <code>&#39;span&#39;</code> 传递给 <code>React.createElement</code>（作为参数）。<strong>大写字母开头的元素则对应着在 JavaScript 引入或自定义的组件</strong>，如 <code>&lt;Foo /&gt;</code> 会编译为 <code>React.createElement(Foo)</code>。</p>
<p>我们建议使用大写字母开头命名自定义组件。如果你确实需要一个以小写字母开头的组件，则在 JSX 中使用它之前，必须将它赋值给一个大写字母开头的变量。</p>
<p>例如，以下的代码将无法按照预期运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">// 错误！组件应该以大写字母开头：</span><br><span class="line">function hello(props) &#123;</span><br><span class="line">  // 正确！这种 &lt;div&gt; 的使用是合法的，因为 div 是一个有效的 HTML 标签</span><br><span class="line">  return &lt;div&gt;Hello &#123;props.toWhat&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function HelloWorld() &#123;</span><br><span class="line">  // 错误！React 会认为 &lt;hello /&gt; 是一个 HTML 标签，因为它没有以大写字母开头：</span><br><span class="line">  return &lt;hello toWhat=&quot;World&quot; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要解决这个问题，我们需要重命名 <code>hello</code> 为 <code>Hello</code>，同时在 JSX 中使用 <code>&lt;Hello /&gt;</code> ：</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/07/05/Hexo%E8%AE%BE%E7%BD%AEMenu/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
      <script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/05/Hexo%E8%AE%BE%E7%BD%AEMenu/" class="post-title-link" itemprop="url">Hexo设置Menu</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-05 21:04:49" itemprop="dateCreated datePublished" datetime="2019-07-05T21:04:49+08:00">2019-07-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E9%A1%B9/" itemprop="url" rel="index"><span itemprop="name">杂项</span></a>
                </span>
            </span>

          
            <span id="/2019/07/05/Hexo%E8%AE%BE%E7%BD%AEMenu/" class="post-meta-item leancloud_visitors" data-flag-title="Hexo设置Menu" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2019/07/05/Hexo%E8%AE%BE%E7%BD%AEMenu/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/07/05/Hexo%E8%AE%BE%E7%BD%AEMenu/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="设置Menu"><a href="#设置Menu" class="headerlink" title="设置Menu"></a>设置Menu</h2><ul>
<li>默认只有两个首页和归档。</li>
</ul>
<h3 id="打开主题的配置文件-config-yml："><a href="#打开主题的配置文件-config-yml：" class="headerlink" title="打开主题的配置文件_config.yml："></a>打开主题的配置文件<code>_config.yml</code>：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  #about: /about/ || user</span><br><span class="line">  #tags: /tags/ || tags</span><br><span class="line">  #categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br><span class="line">  #schedule: /schedule/ || calendar</span><br><span class="line">  #sitemap: /sitemap.xml || sitemap</span><br><span class="line">  #commonweal: /404/ || heartbeat</span><br></pre></td></tr></table></figure>

<p>然后当你要设置某项菜单时，将_config.yml对应的#去除。 然后使用hexo new page xxx生成目录即可</p>
<h3 id="生成“分类”页并添加tpye属性"><a href="#生成“分类”页并添加tpye属性" class="headerlink" title="生成“分类”页并添加tpye属性"></a>生成“分类”页并添加tpye属性</h3><p>打开命令行，进入博客所在文件夹。执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>

<p>成功后会提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/source/categories/index.md</span><br></pre></td></tr></table></figure>

<p>根据上面的路径，找到<code>index.md</code>这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2019-07-05 21:04:49</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>添加<code>type: &quot;categories&quot;</code>到内容中，添加后是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2019-07-05 21:04:49</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>保存并关闭文件。</p>
<h3 id="生成“标签”页并添加tpye属性"><a href="#生成“标签”页并添加tpye属性" class="headerlink" title="生成“标签”页并添加tpye属性"></a>生成“标签”页并添加tpye属性</h3><p>打开命令行，进入博客所在文件夹。执行命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>

<p>成功后会提示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/source/tags/index.md</span><br></pre></td></tr></table></figure>

<p>根据上面的路径，找到<code>index.md</code>这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2019-07-05 21:04:49</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>添加<code>type: &quot;tags&quot;</code>到内容中，添加后是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2019-07-05 21:04:49</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>保存并关闭文件。</p>
<h3 id="给文章添加“tags”、“categories”属性"><a href="#给文章添加“tags”、“categories”属性" class="headerlink" title="给文章添加“tags”、“categories”属性"></a>给文章添加“tags”、“categories”属性</h3><p>打开需要添加标签的文章，为其添加tags属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: jQuery的Dom操作</span><br><span class="line">date: 2019-07-05 21:04:49</span><br><span class="line">categories: </span><br><span class="line">- web前端</span><br><span class="line">tags:</span><br><span class="line">- jQuery</span><br><span class="line">- Dom</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了<code>tags: xxx</code>的文章才会被收录到首页的“标签”中。</p>
<p>打开需要添加分类的文章，为其添加categories属性。下方的<code>categories: web前端</code>表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/07/05/react-redux%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
      <script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/07/05/react-redux%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">react-redux学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-07-05 11:26:36" itemprop="dateCreated datePublished" datetime="2019-07-05T11:26:36+08:00">2019-07-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
                </span>
            </span>

          
            <span id="/2019/07/05/react-redux%E5%AD%A6%E4%B9%A0/" class="post-meta-item leancloud_visitors" data-flag-title="react-redux学习" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2019/07/05/react-redux%E5%AD%A6%E4%B9%A0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/07/05/react-redux%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="redux学习笔记"><a href="#redux学习笔记" class="headerlink" title="redux学习笔记"></a>redux学习笔记</h2><h3 id="学习动机"><a href="#学习动机" class="headerlink" title="学习动机"></a>学习动机</h3><p>随着 JavaScript 单页应用开发日趋复杂，<strong>JavaScript 需要管理比任何时候都要多的 state （状态）</strong>。 这些 state 可能包括服务器响应、缓存数据、本地生成尚未持久化到服务器的数据，也包括 UI 状态，如激活的路由，被选中的标签，是否显示加载动效或者分页器等等。</p>
<h4 id="使用的情形"><a href="#使用的情形" class="headerlink" title="使用的情形"></a>使用的情形</h4><ul>
<li><p>用户的使用方式复杂</p>
</li>
<li><p>不同身份的用户有不同的使用方式（比如普通用户和管理员）</p>
</li>
<li><p>多个用户之间可以协作</p>
</li>
<li><p>与服务器大量交互，或者使用了WebSocket</p>
</li>
<li><p>View要从多个来源获取数据</p>
</li>
<li><p>从组件角度看，如果你的应用有以下场景，可以考虑使用 Redux。</p>
<blockquote>
<ul>
<li>某个组件的状态，需要共享</li>
<li>某个状态需要在任何地方都可以拿到</li>
<li>一个组件需要改变全局状态</li>
<li>一个组件需要改变另一个组件的状态</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="核心api"><a href="#核心api" class="headerlink" title="核心api"></a>核心api</h3><p>createStore  可以帮助我们创建一个store</p>
<p>store.dispatch  帮助我们派发action 这个action会传递给store</p>
<p>store.getState  获取到store里面所有的数据内容</p>
<p>store.subscribe  可以让我们订阅(监听) store的改变 只要store发生改变， 这个方法的回调函数就会执行。</p>
<h4 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h4><p>Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。</p>
<p>Redux 提供<code>createStore</code>这个函数，用来生成 Store。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>createStore</code>函数接受另一个函数作为参数，返回新生成的 Store 对象。</p>
<p>State</p>
<p><code>Store</code>对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。</p>
<p>当前时刻的 State，可以通过<code>store.getState()</code>拿到。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = store.getState();</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。</p>
<h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。</p>
<p>Action 是一个对象。其中的<code>type</code>属性是必须的，表示 Action 的名称。其他属性可以自由设置，社区有一个<a target="_blank" rel="noopener" href="https://github.com/acdlite/flux-standard-action">规范</a>可以参考。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">  <span class="attr">payload</span>: <span class="string">&#x27;Learn Redux&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，Action 的名称是<code>ADD_TODO</code>，它携带的信息是字符串<code>Learn Redux</code>。</p>
<p>可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。</p>
<h4 id="Action-Creator"><a href="#Action-Creator" class="headerlink" title="Action Creator"></a>Action Creator</h4><p>View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ADD_TODO = <span class="string">&#x27;添加 TODO&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: ADD_TODO,</span><br><span class="line">    text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> action = addTodo(<span class="string">&#x27;Learn Redux&#x27;</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>addTodo</code>函数就是一个 Action Creator。</p>
<h4 id="store-dispatch"><a href="#store-dispatch" class="headerlink" title="store.dispatch()"></a>store.dispatch()</h4><p><code>store.dispatch()</code>是 View 发出 Action 的唯一方法。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">  <span class="attr">payload</span>: <span class="string">&#x27;Learn Redux&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>store.dispatch</code>接受一个 Action 对象作为参数，将它发送出去。</p>
<p>结合 Action Creator，这段代码可以改写如下。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(addTodo(<span class="string">&#x27;Learn Redux&#x27;</span>));</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h4><p>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</p>
<p>Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="function"><span class="keyword">function</span> (<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> new_state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>Reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。</p>
<p>纯函数是函数式编程的概念，必须遵守以下一些约束。</p>
<blockquote>
<ul>
<li>不得改写参数</li>
<li>不能调用系统 I/O 的API</li>
<li>不能调用<code>Date.now()</code>或者<code>Math.random()</code>等不纯的方法，因为每次会得到不一样的结果</li>
</ul>
</blockquote>
<p>由于 Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State 是一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123; thingToChange &#125;);</span><br><span class="line">  <span class="comment">// 或者</span></span><br><span class="line">  <span class="keyword">return</span> &#123; ...state, ...newState &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// State 是一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...state, newItem];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>最好把 State 对象设成只读。你没法改变它，要得到新的 State，唯一办法就是生成一个新对象。这样的好处是，任何时候，与某个 View 对应的 State 总是一个不变的对象。</p>
<h4 id="store-subscribe"><a href="#store-subscribe" class="headerlink" title="store.subscribe()"></a>store.subscribe()</h4><p>Store 允许使用<code>store.subscribe</code>方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">store.subscribe(listener);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>显然，只要把 View 的更新函数（对于 React 项目，就是组件的<code>render</code>方法或<code>setState</code>方法）放入<code>listen</code>，就会实现 View 的自动渲染。</p>
<h3 id="redux工作流程"><a href="#redux工作流程" class="headerlink" title="redux工作流程"></a>redux工作流程</h3><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016091802.jpg"></p>
<p>首先，用户发出 Action。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(action);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nextState = todoApp(previousState, action);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>State 一旦有变化，Store 就会调用监听函数。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置监听函数</span></span><br><span class="line">store.subscribe(listener);</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>listener</code>可以通过<code>store.getState()</code>得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listerner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> newState = store.getState();</span><br><span class="line">  component.setState(newState);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p><a target="_blank" rel="noopener" href="https://github.com/reactjs/redux">Redux</a> 官方提供的 React 绑定库。 具有高效且灵活的特性。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>React Redux 依赖 <strong>React 0.14 或更新版本。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react-redux</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add react-redux</span><br></pre></td></tr></table></figure>

<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="lt-Provider-store-gt"><a href="#lt-Provider-store-gt" class="headerlink" title="&lt;Provider store&gt;"></a><code>&lt;Provider store&gt;</code></h4><p><code>&lt;Provider store&gt;</code> 使组件层级中的 <code>connect()</code> 方法都能够获得 Redux store。正常情况下，你的根组件应该嵌套在 <code>&lt;Provider&gt;</code> 中才能使用 <code>connect()</code> 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//自定义App组件  Provider组件将store全部提供给被它包裹的组件。 Provider内部的组件都可以获得store里的数据。</span><br><span class="line">const App = (</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;TodoList/&gt;</span><br><span class="line">  &lt;/Provider&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export default connect(mapStateToProps, mapDispatchToProps)(TodoList);  // connect方法与Provider做连接  获取store里的数据</span><br></pre></td></tr></table></figure>

<p>连接 React 组件与 Redux store。</p>
<p>连接操作不会改变原来的组件类。<br>反而<strong>返回</strong>一个新的已与 Redux store 连接的组件类。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li>[<code>mapStateToProps(state, [ownProps]): stateProps</code>] (<em>Function</em>): 如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，<code>mapStateToProps</code> 函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。如果你省略了这个参数，你的组件将不会监听 Redux store。如果指定了该回调函数中的第二个参数 <code>ownProps</code>，则该参数的值为传递到组件的 props，而且只要组件接收到新的 props，<code>mapStateToProps</code> 也会被调用（例如，当 props 接收到来自父组件一个小小的改动，那么你所使用的 ownProps 参数，mapStateToProps 都会被重新计算）。</li>
</ul>
<p><code>mapStateToProps</code> 函数的第一个参数是整个 Redux store 的 state，它返回一个要作为 props 传递的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//把store里的数据映射到组件的props里  </span><br><span class="line">const mapStateToProps = (state) =&gt; &#123;  //state参数里的数据就是store内的数据</span><br><span class="line">  return &#123;</span><br><span class="line">    inputValue: state.inputValue,</span><br><span class="line">    list: state.list</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<ul>
<li>[<code>mapDispatchToProps(dispatch, [ownProps]): dispatchProps</code>] (<em>Object</em> or <em>Function</em>): 如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，对象所定义的方法名将作为属性名；每个方法将返回一个新的函数，函数中<code>dispatch</code>方法会将 action creator 的返回值作为参数执行。这些属性会被合并到组件的 props 中。</li>
</ul>
<p>如果传递的是一个函数，该函数将接收一个 <code>dispatch</code> 函数，然后由你来决定如何返回一个对象，这个对象通过 <code>dispatch</code> 函数与 action creator 以某种方式绑定在一起</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// store.dispatch, props 把store.dispatch方法映射到props里  通过props调用dispatch里的方法改变store的值</span><br><span class="line">const mapDispatchToProps = (dispatch) =&gt; &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    changeInputValue(e) &#123;</span><br><span class="line">      const action = &#123;</span><br><span class="line">        type: &#x27;change_input_value&#x27;,</span><br><span class="line">        value: e.target.value</span><br><span class="line">      &#125;</span><br><span class="line">      dispatch(action)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<p>简写语法注入 <code>todos</code> 和特定的 action 创建函数(<code>addTodo</code> and <code>deleteTodo</code>)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; addTodo, deleteTodo &#125; <span class="keyword">from</span> <span class="string">&#x27;./actionCreators&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">todos</span>: state.todos &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123;</span><br><span class="line">  addTodo,</span><br><span class="line">  deleteTodo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  mapStateToProps,</span><br><span class="line">  mapDispatchToProps</span><br><span class="line">)(TodoApp)</span><br></pre></td></tr></table></figure>



<p>附上自己写的react + redux小Demo仓库：<a target="_blank" rel="noopener" href="https://github.com/fuchengjx/ReduxDemo">https://github.com/fuchengjx/ReduxDemo</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/06/30/%E6%B5%85%E8%B0%88class/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
      <script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/06/30/%E6%B5%85%E8%B0%88class/" class="post-title-link" itemprop="url">浅谈class</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-06-30 09:17:53" itemprop="dateCreated datePublished" datetime="2019-06-30T09:17:53+08:00">2019-06-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
                </span>
            </span>

          
            <span id="/2019/06/30/%E6%B5%85%E8%B0%88class/" class="post-meta-item leancloud_visitors" data-flag-title="浅谈class" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2019/06/30/%E6%B5%85%E8%B0%88class/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/06/30/%E6%B5%85%E8%B0%88class/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>类实质是个”特殊的函数”，就像你能够定义的函数表达式和函数声明一样， 类语法有两个组成部分： 类表达式和类声明。</p>
<p>class的本质是function。它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程语言的语法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Ponit &#123; // 类声明 按照书写习惯 类名要大写 就像构造函数一样。</span><br><span class="line">	constructor(x, y) &#123;</span><br><span class="line">		this.x = x;</span><br><span class="line">		this.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	toString() &#123;</span><br><span class="line">		return this.x + this.y</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">typeof Ponit // &quot;function&quot;</span><br><span class="line">Point === Point.prototype.constructor // true</span><br><span class="line"></span><br><span class="line">let p = new Ponit() //类的实例化 p为实例对象</span><br></pre></td></tr></table></figure>

<p>上面的代码表明，类的数据类型就是函数，类本身就指向构造函数。 使用的时候也是直接对类使用new命令，和构造函数的用法一样。</p>
<p>构造函数的prototype属性在ES6的”类”上继续存在。事实上，类的所有方法都定义在prototype属性上。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class B &#123;</span><br><span class="line">	constructor() &#123;</span><br><span class="line">		//...</span><br><span class="line">	&#125;</span><br><span class="line">	toString() &#123;</span><br><span class="line">		//...</span><br><span class="line">	&#125;</span><br><span class="line">	toValue() &#123;</span><br><span class="line">		//...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">B.prototype = &#123;</span><br><span class="line">	constructor() &#123;&#125;,</span><br><span class="line">	toString() &#123;&#125;,</span><br><span class="line">	toValue() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b = new B()</span><br><span class="line">b.constructor === B.prototype.constructor // true	在类的实例上调用方法，其实就是调用原型上的方法。</span><br></pre></td></tr></table></figure>

<p>由于类的方法(除constructor以外)都定义在prototype对象上，所以类的新方法可以添加在prototype对象上。  另外，类的内部定义的所有方法都是不可枚举的。</p>
<h4 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h4><p>函数声明和类声明宅男有一个重要区别是函数声明会提升，类声明不会。你首先需要声明你的类，然后访问它，否则代码会抛出一个ReferenceError。 所以在继承中也<strong>必须</strong>保证之类在父类后定义</p>
<h3 id="constructor方法"><a href="#constructor方法" class="headerlink" title="constructor方法"></a>constructor方法</h3><p>constructor方法是类的默认方法，通过new命令生成对象实例时自动调用该方法。一个类必须有constructor方法，如果显示定义，JavaScript引擎会自动为它添加一个空的constructor方法。</p>
<p>constructor方法默认返回实例对象(即this)，不过完全可以定返回另外一个对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">	constructor() &#123;</span><br><span class="line">		return Object.create(null)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new Foo() instanceof Foo // false </span><br></pre></td></tr></table></figure>

<p>一个类只能拥有一个名为 “constructor”的特殊方法。如果类包含多个<code>constructor</code>的方法，则将抛出 一个<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError"><code>SyntaxError</code></a> 。</p>
<p>一个构造函数可以使用 <code>super</code> 关键字来调用一个父类的构造函数。</p>
<h3 id="类的实例对象"><a href="#类的实例对象" class="headerlink" title="类的实例对象"></a>类的实例对象</h3><p>生成实例对象的写法和ES5完全一样，也是使用new命令。如果忘记加上new, 像函数那样调用Class将会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">let point = Point()</span><br><span class="line"></span><br><span class="line">// 正确</span><br><span class="line">let point = new Point()</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class P &#123;</span><br><span class="line">	constructor(x, y) &#123;</span><br><span class="line">		this.x = x;</span><br><span class="line">		this.y = y;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	toString() &#123;</span><br><span class="line">		// ...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p =  new P(2, 3)</span><br><span class="line">p.hasOwnProperty(&#x27;x&#x27;) // true</span><br><span class="line">p.hasOwnProperty(&#x27;toString&#x27;) // false </span><br></pre></td></tr></table></figure>

<p>上面代码中，x和y都是实例对象p自身的属性(因为定义在this变量上)，所以hasOwnProperty方法返回true。而toString是原型对象的属性(因为定义在P类上)，所以hasOwnProperty方法返回false。</p>
<p>与ES5一样，类的所有实例共享一个原型对象。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let p1 = new P(2, 3)</span><br><span class="line">let p2 = new P(4, 5)</span><br><span class="line"></span><br><span class="line">p1.__proto__ === p2.__proto__  // true</span><br></pre></td></tr></table></figure>

<p>上面的代码中，p1和p2都是P的实例，它们的原型都是P.prototype,所以 <code>__proto__</code>属性是相等的。这也意味着，可以通过实例的 <code>__proto__</code>属性为类添加方法。</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>类相对于实例的原型，所有在类中定义的方法都会被实例继承。如果在一个方法前加上static关键字，就表示该方法不会被实例继承，而是直接通过类调用，成为”静态方法”。</p>
<p><code>static</code> 关键字用来定义一个类的一个静态方法。调用静态方法不需要<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript#The_object_(class_instance)">实例化</a>该类，但不能通过一个类实例调用静态方法。静态方法通常用于为一个应用程序创建工具函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="title">distance</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> dx = a.x - b.x;</span><br><span class="line">        <span class="keyword">const</span> dy = a.y - b.y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.hypot(dx, dy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Point(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Point(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Point.distance(p1, p2));</span><br></pre></td></tr></table></figure>

<h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">Foo.prop = 1</span><br><span class="line">console.log(Foo.prop) // 1</span><br></pre></td></tr></table></figure>

<p>上面的写法可读/写Foo类的静态属性prop。  目前，只有这种学法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/05/28/css%E4%B8%96%E7%95%8C%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
      <script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/28/css%E4%B8%96%E7%95%8C%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">css世界笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-28 10:09:40" itemprop="dateCreated datePublished" datetime="2019-05-28T10:09:40+08:00">2019-05-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
                </span>
            </span>

          
            <span id="/2019/05/28/css%E4%B8%96%E7%95%8C%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="css世界笔记" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2019/05/28/css%E4%B8%96%E7%95%8C%E7%AC%94%E8%AE%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/05/28/css%E4%B8%96%E7%95%8C%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是我浅读&lt;&lt;css世界&gt;&gt;的一些体会与笔记</p>
<h2 id="css流"><a href="#css流" class="headerlink" title="css流"></a>css流</h2><p><strong>流</strong>: 就是”文档流”, “流”实际上是css世界中的一种基本的定位和布局机制，与现实中的水流有着异曲同工的表现。所谓流，就是css世界中引导元素排列和定位的一条看不见的”水流”。</p>
<h3 id="流体布局"><a href="#流体布局" class="headerlink" title="流体布局"></a>流体布局</h3><p>指的是利用元素”流”的特性实现的各类布局效果。<div>是典型的具有”流”特性的元素。</p>
<h2 id="流、元素与基本尺寸"><a href="#流、元素与基本尺寸" class="headerlink" title="流、元素与基本尺寸"></a>流、元素与基本尺寸</h2><p>HTML中虽然标签种类繁多，但通常我们就把它们分为两类：块级元素(block-level element)和内联元素(inline element)。</p>
<h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><p>常见的块级元素有div、li和table等，它们都符合块级元素的基本特征—也就是一个水平流上只能单独显示一个元素，多个块级元素则换行显示。</p>
<p>每个元素都有两个盒子，外在盒子和内在盒子。外在盒子负责元素是可以一行显示，还是只能换行显示；内在盒子负责宽高、内容呈现什么的。 按照display的属性值不同，值为block的元素的盒子实际由外在的”块级盒子”和内在的”块级容器盒子”组成，值为inline-block的元素则由外在的”内联盒子”和内在的”块级容器盒子”组成，值为inline的元素则是内外均为”内联盒子”。</p>
<p>这也就是为什么属性为inline-block的元素既能和图文一行显示，又能直接设置width/height的原因了，因为有两个盒子，外面的盒子是inline级别，里面的盒子是block级别。</p>
<h3 id="width-height"><a href="#width-height" class="headerlink" title="width/height"></a>width/height</h3><p>width/height也是作用在内在盒子，也就是”容器盒子中”</p>
<p>width的默认值是auto。非常深藏不露的家伙，’外部尺寸’的宽带最好不要设置，因为一旦设置，流动性就会丢失</p>
<h4 id="格式化宽度。"><a href="#格式化宽度。" class="headerlink" title="格式化宽度。"></a><strong>格式化宽度</strong>。</h4><p>仅出现在”绝对定位模型中”，也就是出现在position属性值为absolute或fixed的元素中。在默认情况下，绝对定位元素的宽度表现是”包裹性”,宽度由内部尺寸决定。 但是，有一种情况是由外部尺寸决定的，对于非替换元素，当left/right或top/bottom对立方位的属性值同时存在的时候，元素的宽度表现为”格式化宽度”，其宽度大小相对于最近的定位特性(postion属性值不少 static)的祖先元素计算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div &#123; postion: absoulte; left: 20px; right: 20px&#125;</span><br><span class="line">//该div元素相对与最近的具有定位特性的祖先元素的宽度是1000px, 则这个div元素的宽度为 960px  1000-20-20</span><br></pre></td></tr></table></figure>

<p>此外，和上面的普通流一样，”格式化宽度”具有完全的流体性，也就是margin、border、padding和content内容区域同样会自动分配水平(和垂直)空间。</p>
<h4 id="最大宽度"><a href="#最大宽度" class="headerlink" title="最大宽度"></a><strong>最大宽度</strong></h4><p>如果内部没有块级元素或者块级元素没有设定宽度值，则”最大宽度”实际上是最大的连续内联盒子的宽度。</p>
<h4 id="css流体布局下的宽度分离原则"><a href="#css流体布局下的宽度分离原则" class="headerlink" title="css流体布局下的宽度分离原则"></a><strong>css流体布局下的宽度分离原则</strong></h4><p>所谓宽度分离原则，就是css中的width属性不与影响宽度的padding/border(有时候包括margin)属性共存。也就是分两层嵌套标签写。父元素写width，子元素写padding、margin。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;father&quot;&gt;</span><br><span class="line">	&lt;div class=&quot;son&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//css样式</span><br><span class="line">.father &#123;</span><br><span class="line">	width: 180px</span><br><span class="line">&#125;</span><br><span class="line">.son &#123;</span><br><span class="line">	margin: 0 20px;</span><br><span class="line">	padding: 20px;</span><br><span class="line">	border:1px solid;</span><br><span class="line">&#125;</span><br><span class="line">//width独立占用一层标签，而padding、border、margin利用流动性在内部自适应呈现。</span><br></pre></td></tr></table></figure>

<h4 id="改变width-height作用细节的box-sizing"><a href="#改变width-height作用细节的box-sizing" class="headerlink" title="改变width/height作用细节的box-sizing"></a><strong>改变width/height作用细节的box-sizing</strong></h4><p>box-sizing改变了width作用的盒子。<strong>内在盒子</strong>：他们分别是content box、padding box、border box、margin box。默认情况下width作用在content box上的， box-sizing的作用就是可以把width作用的盒子变成其他几个。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.box1 &#123;box-sizing: content-box&#125; /*默认值*/</span><br><span class="line">.box2 &#123;box-sizing: padding-box&#125; /*Firefox曾经支持过*/</span><br><span class="line">.box3 &#123;box-sizing: border-box&#125; /*全部浏览器支持 一半修改都是用这个*/</span><br><span class="line">.box4 &#123;box-sizing: margin-box&#125; /*从未支持过*/</span><br></pre></td></tr></table></figure>

<p>当 .box3 {box-sizing: border-box}时， contetn box从宽度值中释放，形成局部流动性，和padding一起自动分配width值。</p>
<h4 id="关于height：100"><a href="#关于height：100" class="headerlink" title="关于height：100%"></a>关于height：100%</h4><p>height和width还有一个明显的区别就是对百分比定位的支持。对于width属性，就算父元素width为auto，其百分比也是支持的；但是，对于height属性，如果父元素height为auto，只要子元素在文档流中，其百分比值就完全被忽略。</p>
<p>eg：某个小白想要在页面插入一个<div>,然后满屏显示背景图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	width: 100%; /* 这是多余的 */</span><br><span class="line">	height: 100%; /* 这是多余的 */</span><br><span class="line">	background: url(bg.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个div高度永远是0，哪怕其父级<body>塞满内容也是如此。事实上，他需要如下设置才行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">html, body &#123;</span><br><span class="line">	height: 100%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用绝对定位。</span><br><span class="line">div &#123;</span><br><span class="line">	height: 100%;</span><br><span class="line">	position: absolute;</span><br><span class="line">&#125;</span><br><span class="line">此时的height: 100%就会有计算值，但是绝对定位的宽高百分比是相对padding box的，非绝对定位是相对于content box计算的。</span><br></pre></td></tr></table></figure>

<p>浏览器渲染的基本原理。从上到下、自内而外的顺序渲染DOM内容。</p>
<h4 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h4><p>min-width/min-height的初始值都是auto</p>
<p>max-width/max-height的初始值都是none</p>
<p>max-width会覆盖 width !important ， min-width会覆盖max-width。</p>
<h3 id="内联元素"><a href="#内联元素" class="headerlink" title="内联元素"></a>内联元素</h3><p><strong>定义</strong> “内联元素”的内联 特指 外在盒子。</p>
<h4 id="内联盒模型"><a href="#内联盒模型" class="headerlink" title="内联盒模型"></a><strong>内联盒模型</strong></h4><ol>
<li>内容区域。内容区域指一种围绕文字看不见的盒子，其大小仅受字符本身特性控制，本质是一个字符盒子；但是有些元素，如图片这样的替换元素，其内容显然不是文字，不存在字符盒子子类的，因此，对于这些元素，内容区域可以看成元素自身。</li>
<li>内联盒子。”内联盒子”不会让内容块显示，而是排成一行，这里的”内联盒子”实际指的就是元素的”外在盒子”，用来决定是内联还是块级。该盒子又可以细分为”内联盒子”和”匿名内联盒子”。 如果外部含内联标签(<span>、<a>和<em>)等；如果是个光秃秃的文字，则属于”匿名内联盒子” 需要值得注意的是，并不是所有光秃秃的文字都是”匿名内联盒子”，其还有可能是”匿名块级盒子”，关键看前后的标签是内联还是块级。</li>
</ol>
<h4 id="幽灵空白节点"><a href="#幽灵空白节点" class="headerlink" title="幽灵空白节点"></a>幽灵空白节点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;span&gt;&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">此时div的高度并不是，而是18px</span><br></pre></td></tr></table></figure>

<p>我们认为在span元素前面还有个宽度为0的空白字符。</p>
<h1 id="盒尺寸四大家族"><a href="#盒尺寸四大家族" class="headerlink" title="盒尺寸四大家族"></a>盒尺寸四大家族</h1><p>content、 padding、 border、 margin</p>
<h2 id="深入理解content"><a href="#深入理解content" class="headerlink" title="深入理解content"></a>深入理解content</h2><h4 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h4><p>根据是否具有替换内容，我们可以把元素分为替换元素和非替换元素。替换元素，顾名思义，内容可以被替换。</p>
<p>这种通过修改某个属性值呈现的内容就可以被替换的元素称为”替换元素”。因此img、object、video、iframe或者表单元素textarea和input都是典型的替换元素。</p>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a><strong>特性</strong></h5><p> 内容的外观不受页面上的css的影响。 有自己的尺寸， 可替换元素的baseline为元素的下边缘。</p>
<p>input white-space pre  当文字足够多的时候，按钮不会自动换行</p>
<p>button white-space normal  会自动换行</p>
<h5 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a><strong>尺寸</strong></h5><p> 从内到外分为 固有尺寸、html尺寸、css尺寸。 默认全部为px单位。 </p>
<ol>
<li><p>固有尺寸 替换内容的原本尺寸，不加修饰的尺寸。 <input> 这样就是固有尺寸  img插入图片原来的大小 无法改变这个替换元素的固有尺寸。 </p>
</li>
<li><p>html尺寸 只能通过html原生属性改变。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;img width=&quot;300&quot; height=&quot;100&quot;&gt;</span><br><span class="line">&lt;input size-&quot;30&quot;&gt;</span><br><span class="line">&lt;textarea cols=&quot;3&quot;&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>css尺寸对应content box。 通过css的width和height设置。</p>
</li>
</ol>
<p>css样式优先级最高</p>
<h4 id="content与替换元素关系剖析"><a href="#content与替换元素关系剖析" class="headerlink" title="content与替换元素关系剖析"></a>content与替换元素关系剖析</h4><p>content属性生成的对象称为”匿名替换元素”，content生成的内容都是替换元素。</p>
<p>content生成的文本都是无法选中的、无法复制的。替换的仅仅是视觉层。</p>
<p><strong>所以重要的内容千万不能用content生成，对可访问性和seo不友好</strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/05/24/%E6%B5%85%E8%B0%88async%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
      <script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/24/%E6%B5%85%E8%B0%88async%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">浅谈async函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-24 09:59:59" itemprop="dateCreated datePublished" datetime="2019-05-24T09:59:59+08:00">2019-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
                </span>
            </span>

          
            <span id="/2019/05/24/%E6%B5%85%E8%B0%88async%E5%87%BD%E6%95%B0/" class="post-meta-item leancloud_visitors" data-flag-title="浅谈async函数" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2019/05/24/%E6%B5%85%E8%B0%88async%E5%87%BD%E6%95%B0/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/05/24/%E6%B5%85%E8%B0%88async%E5%87%BD%E6%95%B0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><h3 id="async-1"><a href="#async-1" class="headerlink" title="async"></a>async</h3><p>ES2017标准引入了async函数，使得异步操作变得更加方便。</p>
<p>async的改进之处</p>
<ol>
<li>async和await比起星号和yield，语义更加清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li>
<li>async函数的返回值是Promise对象，这比Generator函数的返回值是Iterator对象方便了许多。可以用then方法指定下一步操作。 进一步说，async函数完全可以看做由多个异步操作包装成的一个Promise对象，而await命令就是内部then命令的语法糖。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function getValueA() &#123;</span><br><span class="line">    let promise = new Promise(function (resolve, reject) &#123;</span><br><span class="line">        setTimeout(()=&gt;&#123;</span><br><span class="line">            console.log(&quot;i am a getValueA&quot;)</span><br><span class="line">            resolve(2)</span><br><span class="line">        &#125;,2000)</span><br><span class="line">    &#125;)</span><br><span class="line">    return promise</span><br><span class="line">&#125;</span><br><span class="line">function getValueB() &#123;</span><br><span class="line">    let promise = new Promise(function (resolve, reject) &#123;</span><br><span class="line">        setTimeout(()=&gt;&#123;</span><br><span class="line">            console.log(&quot;i am a getValueB&quot;)</span><br><span class="line">            resolve(4)</span><br><span class="line">        &#125;,4000)</span><br><span class="line">    &#125;)</span><br><span class="line">    return promise</span><br><span class="line">&#125;</span><br><span class="line">function getValueC(a, b) &#123;</span><br><span class="line">    let promise = new Promise(function (resolve, reject) &#123;</span><br><span class="line">        setTimeout(()=&gt;&#123;</span><br><span class="line">            console.log(&quot;i am a getValueC&quot;)</span><br><span class="line">            resolve(3)</span><br><span class="line">        &#125;,3000)</span><br><span class="line">    &#125;)</span><br><span class="line">    return promise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function getABC() &#123;</span><br><span class="line">    let A = await getValueA()</span><br><span class="line">    let B = await getValueB()</span><br><span class="line">    let C = await getValueC(A,B) //将A,B的返回值传递给getABC()</span><br><span class="line">    return A*B*C //24</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>async函数返回一个Promise对象</p>
<p>async函数内部return语句返回的值，会成为then方法回调函数的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">	return &#x27;hello world&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(v =&gt; &#123;</span><br><span class="line">	console.log(v) //&#x27;hello world&#x27; </span><br><span class="line">&#125;</span><br><span class="line">//上面的代码中，函数f内部return命令返回的值会被then方法回调函数接收到。</span><br><span class="line"></span><br><span class="line">async function f() &#123;</span><br><span class="line">	throw new Error(&#x27;出错了&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(v =&gt; &#123;</span><br><span class="line">	console.log(v) //&#x27;Error： 出错了&#x27; </span><br><span class="line">&#125;</span><br><span class="line">//async函数内部抛出错误会导致放回的Promise对象变为reject状态。 抛出的错误对象会被catch方法回调函数接收到</span><br></pre></td></tr></table></figure>



<h3 id="await命令"><a href="#await命令" class="headerlink" title="await命令"></a>await命令</h3><p>正常情况下，await命令后面是一个Promise对象。如果不是，会被转成一个立即resolve的Promise对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">	return await 123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(v =&gt; console.log(v)) //123</span><br></pre></td></tr></table></figure>

<p>上面的代码中，await命令的参数是数值的123，它被转成Promise对象并立即resolve。</p>
<p>如果await后面的异步操作出错，那么等同于async函数返回的Promise对象被reject</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">	await new Promise(function (resolve, reject) &#123;</span><br><span class="line">		throw new Error(&#x27;出错了&#x27;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(v =&gt; console.log(v))</span><br><span class="line">.catch( e =&gt; console.log(e)) //Error: 出错了</span><br></pre></td></tr></table></figure>



<p>多个await命令后面的异步操作如果不存在继发关系，最好让它们同时触发。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let foo = await getFoo();</span><br><span class="line">let bar = await getBar();</span><br><span class="line">//上面的代码中，getFoo和getBar是两个独立的异步操作(及互不依赖)被写成继发关系。这样比较耗时，因为只有getFoo完成后才会执行getBar，完全可以让它们同时触发。</span><br><span class="line"></span><br><span class="line">//写法一</span><br><span class="line">let [foo, bar] = await Promise.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line">//写法二</span><br><span class="line">let fooPromise = getFoo();</span><br><span class="line">let barPromise = getBar();</span><br><span class="line">let foo = await fooPromise;</span><br><span class="line">let bar = await barPromise;</span><br></pre></td></tr></table></figure>

<p>上面两种写法中，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。</p>
<h3 id="async函数的实现原理"><a href="#async函数的实现原理" class="headerlink" title="async函数的实现原理"></a>async函数的实现原理</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">async function fn(args) &#123;</span><br><span class="line">	// ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//等于</span><br><span class="line">function fn（args) &#123;</span><br><span class="line">	return spawn(function* () &#123;</span><br><span class="line">		// ...</span><br><span class="line">	&#125;)</span><br><span class="line">&#125; </span><br><span class="line">//所有的async函数都可以写成上面第二种形式，其中的spawn函数就是自动执行器。</span><br><span class="line"></span><br><span class="line">//spawn函数的实现</span><br><span class="line">function spawn(genF)  &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        var gen = genF();</span><br><span class="line">        function step(nextF) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                var next = nextF();</span><br><span class="line">            &#125; catch (e) &#123;</span><br><span class="line">                return reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">            if (next.done) &#123;</span><br><span class="line">                return resolve(next.value);</span><br><span class="line">            &#125; </span><br><span class="line">            Promise.resolve(next.value).then(function (e) &#123;</span><br><span class="line">                step(function () &#123;</span><br><span class="line">                    return gen.next(v);</span><br><span class="line">                &#125;, function (e) &#123;</span><br><span class="line">                    step(function () &#123;</span><br><span class="line">                        return gen.throw(e);</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        step(function () &#123;</span><br><span class="line">            return gen.next(undefined);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/05/03/js%E6%B5%85%E8%B0%88promise/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
      <script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/03/js%E6%B5%85%E8%B0%88promise/" class="post-title-link" itemprop="url">js浅谈promise</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-05-03 19:19:20" itemprop="dateCreated datePublished" datetime="2019-05-03T19:19:20+08:00">2019-05-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
                </span>
            </span>

          
            <span id="/2019/05/03/js%E6%B5%85%E8%B0%88promise/" class="post-meta-item leancloud_visitors" data-flag-title="js浅谈promise" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2019/05/03/js%E6%B5%85%E8%B0%88promise/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/05/03/js%E6%B5%85%E8%B0%88promise/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Promise的含义"><a href="#Promise的含义" class="headerlink" title="Promise的含义"></a>Promise的含义</h2><p>所谓Promise， 简单来说是一个容器， 里面保存这未来才会结束的事件(通常是一个异步操作)的结果。</p>
<p><strong>Promise对象有以下两个特点</strong></p>
<ol>
<li>对象的状态不受外界影响。 Promise对象代表一个异步操作，有3种状态： Pending(进行中)、Fulfilled(已成功)和Rejected(已失败)。 只有异步操作的结果可以决定当前是哪一种状态，其他任何操作都不会改变这个状态。</li>
<li>一旦状态改变就不会改变，任何时候都可以得到这个结果。Promise对象的状态改变只能有两种可能：从Pending变化为Fulfilled和从Pending变为Rejected。 </li>
</ol>
<p><strong>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，以避免了层层嵌套的回调函数。</strong></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;...&#125; <span class="comment">/* executor */</span>  );</span><br></pre></td></tr></table></figure>

<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。</p>
<p><strong>resolve函数的作用</strong>是将Promise对象从”未完成”变为”成功”(即从Pending变为Resolved)，在异步操作成功时调用，并将异步操作的结果作为参数传递出去；</p>
<p>reject函数的作用也类似， 不过是(从Pending变为Rejected)，在异步操作失败时调用，并将异步操作的错误作为参数传递出去。</p>
<p>Promise实例生成后，可以用then方法分别指定Resolved和Rejected状态的回调函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let promise = new Promise(function (resolve, reject) &#123;</span><br><span class="line">    console.time(&#x27;st&#x27;)</span><br><span class="line">    console.log(&#x27;start&#x27;)</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;Promise&#x27;)</span><br><span class="line">        resolve(&#x27;par&#x27;); //resolve将参数传给回调函数</span><br><span class="line">        console.timeEnd(&#x27;st&#x27;) //2500ms左右</span><br><span class="line">    &#125;,2500)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(function (res) &#123;</span><br><span class="line">    console.time(&#x27;then&#x27;)</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&quot;Resolved&quot;)</span><br><span class="line">        console.log(res) //par 打印接受到的参数</span><br><span class="line">        console.timeEnd(&#x27;then&#x27;) //1000ms</span><br><span class="line">    &#125;,1000)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#x27;hi&#x27;) </span><br><span class="line"></span><br><span class="line">以上分别输出</span><br><span class="line">start</span><br><span class="line">hi</span><br><span class="line">Promise //2.5s后输出</span><br><span class="line">st: 2500ms</span><br><span class="line">Resolved //1s之后再输出</span><br><span class="line">par</span><br><span class="line">then: 1000ms</span><br></pre></td></tr></table></figure>

<p>上面代码中执行： Promise新建后就会立即执行，所以首先输出start、 然后setTimeout异步执行，然后then方法指定的回调函数将在当前脚本所有同步任务执行完成后才会执行 ，所以Resolved最后输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var p1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">    setTimeout( () =&gt; reject(new Error(&#x27;fail&#x27;)), 3000)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(p1) //Promise &#123; &lt;pending&gt; &#125; 直接打印输出p1实例可以输出当前Promise所处状态</span><br><span class="line">var p2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">    resolve(p1)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2.then( () =&gt; &#123;</span><br><span class="line">    console.log(&quot;i am p2 callback&quot;)</span><br><span class="line">&#125;, (err) =&gt; &#123;</span><br><span class="line"> 	console.log(err) //Promise &#123; &lt;rejected&gt; &#125;</span><br><span class="line">    console.log(err) //Error: fail 因为p1是Rejected，所以p2直接执行rejected函数</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码中p1，p2都是Promise的实例，此时p1的状态会传给p2。也就是说，p1的状态决定了p2的状态。</p>
<p><strong>promise.all()</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var r1 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">    console.time(&#x27;start&#x27;)</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;this is a request1&#x27;)</span><br><span class="line">        console.timeEnd(&#x27;start&#x27;)</span><br><span class="line">    &#125;,3000)</span><br><span class="line">&#125;)</span><br><span class="line">var r2 = new Promise(function (resolve, reject) &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&#x27;this is a request2&#x27;)</span><br><span class="line">    &#125;,3000)</span><br><span class="line">&#125;)</span><br><span class="line">Promise.all([</span><br><span class="line">    r1,</span><br><span class="line">    r2</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">// this is a request1</span><br><span class="line">// start: 3000ms</span><br><span class="line">// this is a request2 </span><br></pre></td></tr></table></figure>

<p>上面代码中r1，r2都是同时输出。 </p>
<p>这个方法返回一个新的promise对象，该promise对象在数组参数里所有的promise对象都成功的时候才会触发成功，一旦数组里面有任何一个的promise对象失败则立即触发该promise对象的失败。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/04/26/%E6%B5%85%E8%B0%88http/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
      <script src="https://cdn.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js"></script>
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/26/%E6%B5%85%E8%B0%88http/" class="post-title-link" itemprop="url">浅谈http</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-26 17:22:48" itemprop="dateCreated datePublished" datetime="2019-04-26T17:22:48+08:00">2019-04-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">计算机网络</span></a>
                </span>
            </span>

          
            <span id="/2019/04/26/%E6%B5%85%E8%B0%88http/" class="post-meta-item leancloud_visitors" data-flag-title="浅谈http" title="Views">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine: </span>
    
    <a title="valine" href="/2019/04/26/%E6%B5%85%E8%B0%88http/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2019/04/26/%E6%B5%85%E8%B0%88http/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h3><p>HTTP (HyperText Transfer Protocol,超文本传输协议)。  Web是建立在HTTP协议通信的。</p>
<p>HTTP 是个应用层协议。HTTP 无需操心网络通信的具体细节；它把联网的细节都<br>交给了通用、可靠的因特网传输协议 TCP/IP。</p>
<p>TCP 提供了：<br>• 无差错的数据传输；<br>• 按序传输（数据总是会按照发送的顺序到达）；<br>• 未分段的数据流（可以在任意时刻以任意尺寸将数据发送出去）。</p>
<h3 id="HTTP资源"><a href="#HTTP资源" class="headerlink" title="HTTP资源"></a>HTTP资源</h3><p>Web 服务器是 Web 资源（Web resource）的宿主。Web 资源是 Web 内容的源头。<br>最简单的 Web 资源就是 Web 服务器文件系统中的静态文件。这些文件可以包含<br>任意内容：文本文件、HTML 文件、微软的 Word 文件、Adobe 的 Acrobat 文件、<br>JPEG 图片文件、AVI 电影文件，或所有其他你能够想到的格式。</p>
<h4 id="MIME"><a href="#MIME" class="headerlink" title="MIME"></a><strong>MIME</strong></h4><p>（Multipurpose Internet Mail Extension，多用途因特网邮件扩展）是为了解决在不同<br>的电子邮件系统之间搬移报文时存在的问题。MIME 在电子邮件系统中工作得非常<br>好，因此 HTTP 也采纳了它，用它来描述并标记多媒体内容</p>
<p>• HTML 格式的文本文档由 text/html 类型来标记。<br>• 普通的 ASCII 文本文档由 text/plain 类型来标记。<br>• JPEG 格式的图片为 image/jpeg 类型。<br>• GIF 格式的图片为 image/gif 类型。<br>• Apple 的 QuickTime 电影为 video/quicktime 类型。<br>• 微软的 PowerPoint 演示文件为 application/vnd.ms-powerpoint 类型</p>
<h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a><strong>URL</strong></h4><p>服务器资源名被称为统一资源标识符（Uniform Resource Identifier，URI）。<br>URI 就像因特网上的邮政地址一样，在世界范围内唯一标识并定位信息资源。</p>
<p>大部分 URL 都遵循一种标准格式，这种格式包含三个部分。<br>• URL 的第一部分被称为方案（scheme），说明了访问资源所使用的协议类型。这<br>部分通常就是 HTTP 协议（http://）。<br>• 第二部分给出了服务器的因特网地址（比如，<a target="_blank" rel="noopener" href="http://www.joes-hardware.com)./">www.joes-hardware.com）。</a><br>• 其余部分指定了 Web 服务器上的某个资源（比如，/specials/saw-blade.gif）</p>
<h3 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h3><p>所有的 HTTP 报文都可以分为两类： 请求报文（request message）和响应报文<br>（response message）。 </p>
<p><strong>请求报文的格式</strong></p>
<p><method> <request-URL> <version></p>
<headers>

<entity-body>

<p>GET /test/hi-there.txt HTTP/1.1<br>Accept: text/*<br>Host: <a target="_blank" rel="noopener" href="http://www.joes-hardware.com/">www.joes-hardware.com</a></p>
<p><strong>响应报文的格式</strong></p>
<p><version> <status> <reason-phrase></p>
<headers>

<entity-body>

<p>HTTP/1.0 200 OK<br>Content-type: text/plain<br>Content-length: 19<br>Hi! I’m a message!</p>
<p><strong>包括以下三个部分</strong>。</p>
<p><strong>• 起始行</strong><br>报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说<br>明出现了什么情况。<br><strong>• 首部字段</strong><br>起始行后面有零个或多个首部字段。每个首部字段都包含一个名字和一个值，为<br>了便于解析，两者之间用冒号（:）来分隔。首部以一个空行结束。添加一个首<br>部字段和添加新行一样简单。<br><strong>• 主体</strong><br>空行之后就是可选的报文主体了，其中包含了所有类型的数据。请求主体中包括<br>了要发送给 Web 服务器的数据；响应主体中装载了要返回给客户端的数据。起<br>始行和首部都是文本形式且都是结构化的，而主体则不同，主体中可以包含任意<br>的二进制数据（比如图片、视频、音轨、软件程序）。当然，主体中也可以包含<br>文本</p>
<h3 id="HTTP方法"><a href="#HTTP方法" class="headerlink" title="HTTP方法"></a>HTTP方法</h3><p><strong>一些常见的HTTP方法</strong></p>
<p>HTTP方法         描　　述<br>GET                 从服务器向客户端发送命名资源<br>PUT                 将来自客户端的数据存储到一个命名的服务器资源中去<br>DELETE          从服务器中删除命名资源<br>POST              将客户端数据发送到一个服务器网关应用程序<br>HEAD             仅发送命名资源响应中的 HTTP 首部</p>
<h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>状态码则用来告诉客户端，发生了什么事情。状态码位于响应的起始行中。比如，在行 HTTP/1.0 200 OK 中，状态码就是 200。</p>
<p>状态码分类：</p>
<p><img src="http://img.flura.cn/%E7%8A%B6%E6%80%81%E7%A0%81%E5%88%86%E7%B1%BB.png" alt="状态码分类"></p>
<p>常见状态码： </p>
<p>100——客户必须继续发出请求</p>
<p>101——客户要求服务器根据请求转换HTTP协议版本</p>
<p>200——交易成功</p>
<p>201——提示知道新文件的URL</p>
<p>202——接受和处理、但处理未完成</p>
<p>203——返回信息不确定或不完整</p>
<p>204——请求收到，但返回信息为空</p>
<p>205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</p>
<p>206——服务器已经完成了部分用户的GET请求</p>
<p>300——请求的资源可在多处得到</p>
<p>301——删除请求数据</p>
<p>302——在其他地址发现了请求数据</p>
<p>303——建议客户访问其他URL或访问方式</p>
<p>304——客户端已经执行了GET，但文件未变化</p>
<p>305——请求的资源必须从服务器指定的地址得到</p>
<p>306——前一版本HTTP中使用的代码，现行版本中不再使用</p>
<p>307——申明请求的资源临时性删除</p>
<p>400——错误请求，如语法错误</p>
<p>401——请求授权失败</p>
<p>402——保留有效ChargeTo头响应</p>
<p>403——请求不允许</p>
<p>404——没有发现文件、查询或URl</p>
<p>405——用户在Request-Line字段定义的方法不允许</p>
<p>406——根据用户发送的Accept拖，请求资源不可访问</p>
<p>407——类似401，用户必须首先在代理服务器上得到授权</p>
<p>408——客户端没有在用户指定的时间内完成请求</p>
<p>409——对当前资源状态，请求不能完成</p>
<p>410——服务器上不再有此资源且无进一步的参考地址</p>
<p>411——服务器拒绝用户定义的Content-Length属性请求</p>
<p>412——一个或多个请求头字段在当前请求中错误</p>
<p>413——请求的资源大于服务器允许的大小</p>
<p>414——请求的资源URL长于服务器允许的长度</p>
<p>415——请求资源不支持请求项目格式</p>
<p>416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</p>
<p>417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求</p>
<p>500——服务器产生内部错误</p>
<p>501——服务器不支持请求的函数</p>
<p>502——服务器暂时不可用，有时是为了防止发生系统过载</p>
<p>503——服务器过载或暂停维修</p>
<p>504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长</p>
<p>505——服务器不支持或拒绝支请求头中指定的HTTP版本</p>
<h3 id="HTTP的结构组件"><a href="#HTTP的结构组件" class="headerlink" title="HTTP的结构组件"></a>HTTP的结构组件</h3><p>在本章的概述中，我们重点介绍了两个 Web 应用程序（Web 浏览器和 Web 服务器）<br>是如何相互发送报文来实现基本事务处理的。在因特网上，要与很多 Web 应用程序<br>进行交互。在本节中，我们将列出其他一些比较重要的应用程序，如下所示。<br>• 代理<br>位于客户端和服务器之间的 HTTP 中间实体。<br>• 缓存<br>HTTP 的仓库，使常用页面的副本可以保存在离客户端更近的地方。<br>• 网关<br>连接其他应用程序的特殊 Web 服务器。<br>• 隧道<br>对 HTTP 通信报文进行盲转发的特殊代理。<br>• Agent 代理<br>发起自动 HTTP 请求的半智能 Web 客户端。</p>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p><img src="http://img.flura.cn/%E4%BB%A3%E7%90%86.png" alt="代理"></p>
<p>代理位于客户端和服务器之间，接收所有客户端的 HTTP 请求，并<br>将这些请求转发给服务器（可能会对请求进行修改之后转发）。对用户来说，这些应<br>用程序就是一个代理，代表用户访问服务器。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p><img src="http://img.flura.cn/%E7%BC%93%E5%AD%98.png" alt="缓存"></p>
<p>Web 缓存（Web cache）或代理缓存（proxy cache）是一种特殊的 HTTP 代理服务<br>器，可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端<br>就可以享受缓存的私有副本所提供的服务了。 客户端从附近的缓存下载文档会比从远程 Web 服务器下载快得多。</p>
<h4 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h4><p><img src="http://img.flura.cn/%E7%BD%91%E5%85%B3.png" alt="隧道"></p>
<p>网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于<br>将 HTTP 流量转换成其他的协议。网关接受请求时就好像自己是资源的源端服务器<br>一样。客户端可能并不知道自己正在与一个网关进行通信。</p>
<h4 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h4><p><img src="http://img.flura.cn/%E9%9A%A7%E9%81%93.png" alt="隧道"></p>
<p>隧道（tunnel）是建立起来之后，就会在两条连接之间对原始数据进行盲转发的<br>HTTP 应用程序。HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数<br>据，转发时不会窥探数据。</p>
<p>HTTP 隧道的一种常见用途是通过 HTTP 连接承载加密的安全套接字层（SSL，<br>Secure Sockets Layer）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防<br>火墙了。如图 所示，HTTP/SSL 隧道收到一条 HTTP 请求，要求建立一条到目<br>的地址和端口的输出连接，然后在 HTTP 信道上通过隧道传输加密的 SSL 流量，这<br>样就可以将其盲转发到目的服务器上去了</p>
<h4 id="Agent-代理"><a href="#Agent-代理" class="headerlink" title="Agent 代理"></a>Agent 代理</h4><p>用户 Agent 代理（或者简称为 Agent 代理）是代表用户发起 HTTP 请求的客户端程<br>序。(也被叫做爬虫、网络蜘蛛、web机器人），是一种按照一定的规则，自动地抓取<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%87%E7%BB%B4%E7%BD%91/215515">万维网</a>信息的程序或者脚本。另外一些不常使用的名字还有<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%9A%82%E8%9A%81/9770178">蚂蚁</a>、自动索引、模拟程序或者<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%A0%95%E8%99%AB/4454380">蠕虫</a>。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>HTTPS 是最常见的 HTTP 安全版本。它得到了很广泛的应用，所有主要的商业浏览<br>器和服务器上都提供 HTTPS。HTTPS 将 HTTP 协议与一组强大的对称、非对称和<br>基于证书的加密技术结合在一起，使得 HTTPS 不仅很安全，而且很灵活，很容易<br>在处于无序状态的、分散的全球互联网上进行管理。</p>
<p><img src="http://img.flura.cn/http%E5%88%86%E5%B1%82.png" alt="https分层"></p>
<p>HTTPS = HTTP + SSL(或TLS) + 认证(证书) + 加密(加密算法)</p>
<h4 id="HTTP和HTTPS协议的区别"><a href="#HTTP和HTTPS协议的区别" class="headerlink" title="HTTP和HTTPS协议的区别"></a>HTTP和HTTPS协议的区别</h4><p>1、HTTPS协议需要到证书颁发机构(Certificate Authority，简称CA)<a target="_blank" rel="noopener" href="https://www.wosign.com/price.htm">申请证书</a>，一般免费证书很少，需要交费。</p>
<p>2、HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议。</p>
<p>3、HTTP和HTTPS使用的是完全不同的连接方式，使用的端口也不一样,前者是80,后者是443。</p>
<p>4、HTTP的连接很简单,是无状态的。</p>
<p>5、HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比HTTP协议安全。</p>
<p>从上面可看出，HTTPS和HTTP协议相比提供了</p>
<p>· 数据完整性：内容传输经过完整性校验</p>
<p>· 数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥</p>
<p>· 身份认证：第三方无法伪造服务端(客户端)身份</p>
<p>其中，数据完整性和隐私性由TLS Record Protocol保证，身份认证由TLS Handshaking Protocols实现。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="flura"
      src="http://img.flura.cn/myAvatar.jpg">
  <p class="site-author-name" itemprop="name">flura</p>
  <div class="site-description" itemprop="description">flura的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/fuchengjx" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;fuchengjx" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/327619852@qq.com" title="E-Mail → 327619852@qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">赣ICP备18002942号 </a>
  </div>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">flura</span>
</div>

        






<script>
  (function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"JEwUnCMXWy18dkpgByL1QYAR-gzGzoHsz","app_key":"l1V40QU1cms7REi7DYrNungE","server_url":null,"security":true,"betterPerformance":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        // if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();
</script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'JEwUnCMXWy18dkpgByL1QYAR-gzGzoHsz',
      appKey     : 'l1V40QU1cms7REi7DYrNungE',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
