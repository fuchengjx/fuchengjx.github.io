<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.flura.cn","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","width":300,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="flura的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="flura的博客">
<meta property="og:url" content="http://www.flura.cn/index.html">
<meta property="og:site_name" content="flura的博客">
<meta property="og:description" content="flura的个人博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="flura">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.flura.cn/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>flura的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">flura的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags<span class="badge">33</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">5</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">34</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2020/02/29/vue%E7%9A%84%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/02/29/vue%E7%9A%84%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82/" class="post-title-link" itemprop="url">vue的路由传参</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-02-29 20:04:16" itemprop="dateCreated datePublished" datetime="2020-02-29T20:04:16+08:00">2020-02-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-23 23:31:22" itemprop="dateModified" datetime="2021-10-23T23:31:22+08:00">2021-10-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="vue-router传参方式"><a href="#vue-router传参方式" class="headerlink" title="vue-router传参方式"></a>vue-router传参方式</h1><p>当发生组件跳转时，组件a 跳转到 组件b，数据的流动是单向的，那么可以考虑使用vue-router的方式传递参数。 vue-router的传参分为3种, 一种是query，一种是params，还有一种动态路由传参比较特殊。 下面来具体总结一下。</p>
<h2 id="query方式传参和接收参数"><a href="#query方式传参和接收参数" class="headerlink" title="query方式传参和接收参数"></a>query方式传参和接收参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A组件跳转到B组件，通过query传参。</span><br><span class="line">this.$router.push(&#123;</span><br><span class="line">  name: &quot;PageB&quot;,</span><br><span class="line">  query: &#123;</span><br><span class="line">    id: 2,</span><br><span class="line">    content: &quot;这是id为2的content&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B组件接收A组件传递过来的参数</span><br><span class="line">this.$route.query.id  // 2</span><br><span class="line">this.$route.query.content // &quot;这是id为2的content&quot;</span><br></pre></td></tr></table></figure>

<p>ps: 传参是 <strong>this.$router</strong>, 通过VueRouter的实例， 接收参数使用的是 <strong>this.$route</strong>。</p>
<p>而且我们发现 <strong>url（地址栏）</strong>是可以看到 id与content参数的。有点类似于发起get请求时，参数拼接在url中。</p>
<h2 id="params方式传参和接收参数"><a href="#params方式传参和接收参数" class="headerlink" title="params方式传参和接收参数"></a>params方式传参和接收参数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A组件跳转到B组件，通过params传参。</span><br><span class="line">this.$router.push(&#123;</span><br><span class="line">  name: &quot;PageB&quot;,</span><br><span class="line">  params: &#123;</span><br><span class="line">    id: id,</span><br><span class="line">    content: &quot;这是params id为2的content&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B组件接收A组件传递过来的参数</span><br><span class="line">this.$route.params.id  // 2</span><br><span class="line">this.$route.params.content // &quot;这是id为2的content&quot;</span><br></pre></td></tr></table></figure>

<p>ps:  params传参，push里面只能是 name:’xxxx’,不能是path:’/xxx’,因为params只能用name来引入路由。</p>
<p>params方式传参是不会在url中显示的，如果为了美观 还是选择用params方法进行传参。</p>
<h2 id="动态路由传递参数"><a href="#动态路由传递参数" class="headerlink" title="动态路由传递参数"></a>动态路由传递参数</h2><p>一般有种很常见的需求就是做 列表详情页。 一个列表，点击列表中的每一项，进入一个详情页。 而详情页的路由是根据你列表页的点击确定的。每个详情页都有一个对应列表的id，路由是动态的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 文章列表页</span><br><span class="line">&lt;li v-for=&quot;article in articles&quot; @click=&quot;getDetail(article.id)&quot;&gt;</span><br><span class="line"></span><br><span class="line">getDetail(id) &#123;</span><br><span class="line">  //直接调用$router.push 实现携带参数的跳转</span><br><span class="line">  this.$router.push(&#123;</span><br><span class="line">    path: `/detail/$&#123;id&#125;`,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这种方法是需要在对应的路由进行配置的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// router.js</span><br><span class="line">   &#123;</span><br><span class="line">     path: &#x27;/detail/:id&#x27;,</span><br><span class="line">     name: &#x27;Detail&#x27;,</span><br><span class="line">     component: Detail</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// detail.vue 文章详情组件</span><br><span class="line">this.$route.params.id</span><br></pre></td></tr></table></figure>



<h2 id="关于刷新问题"><a href="#关于刷新问题" class="headerlink" title="关于刷新问题"></a>关于刷新问题</h2><p>其实我们开发大多是单页面组件，我们的所有页面都是一个Vue根实例，所有的data，以及vuex都挂载在根实例上，  如果用户刷新页面，我们保存在页面的数据会全部回到初始值，就是保存的状态全部消失。这样的话如果发生了组件跳转，a页面跳转到b页面 a中传递了数据给b。 我们在b页面中刷新，通过常规方法保存的状态都会直接消失，vue-bus、vuex、props之类的传值方式都会获取不到a传过来的值(所以尽量不要刷新)。 </p>
<p>但是vue-router的两种传参方式其实是可以在刷新后获取到 之前的参数的。 我们可以发现刷新后 虽然状态全部没了，但是路由 也可以理解为url在刷新后是不变的。 而通过<strong>query</strong>方式 与<strong>动态路由</strong>方式 都会在跳转后 都会在路由中携带参数，所以通过url传参是可以在刷新后保存上一个页面传递过来的参数的。</p>
<h2 id="vue-router打开新页面"><a href="#vue-router打开新页面" class="headerlink" title="vue-router打开新页面"></a>vue-router打开新页面</h2><p>vue-router怎么点击打开新的页面，就是a标签里的target=“blank</p>
<p>vue本身开发的就是单页面组件，路由跳转其实在浏览器看来并没有跳转(或者说并没有打开页面，本质上还是在一个index.html上)</p>
<h3 id="router-link-标签实现新窗口打开"><a href="#router-link-标签实现新窗口打开" class="headerlink" title="router-link 标签实现新窗口打开"></a>router-link 标签实现新窗口打开</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link target=&quot;_blank&quot;&gt;&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<h3 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h3><p>使用this.$router.resolve</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seeShare()&#123;</span><br><span class="line">     let routeUrl = this.$router.resolve(&#123;</span><br><span class="line">          path: &quot;/share&quot;,</span><br><span class="line">          query: &#123;id:96&#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     window.open(routeUrl.href, &#x27;_blank&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果用这种方法进行参数传递  其实是不能通过params方式进行参数传递的，只能通过query进行传递。其实想想也可以理解，因为_blank打开了一个新的页面，两个html页面之间进行数据传递，最好用的就是url进行传参。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/12/31/%E9%9A%8F%E7%AC%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/31/%E9%9A%8F%E7%AC%94/" class="post-title-link" itemprop="url">随笔</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-31 22:25:36" itemprop="dateCreated datePublished" datetime="2019-12-31T22:25:36+08:00">2019-12-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-23 23:37:48" itemprop="dateModified" datetime="2021-10-23T23:37:48+08:00">2021-10-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9A%8F%E7%AC%94/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这是一篇随笔，记录我的一些人生经历，方便以后自我回顾，以及给我们工作室的学弟学妹一些关于找工作的信息及建议，方便他们少走弯路。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/31/%E9%9A%8F%E7%AC%94/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/12/18/%E5%B8%B8%E8%A7%81%E7%9A%84git%E7%BB%9F%E8%AE%A1%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/12/18/%E5%B8%B8%E8%A7%81%E7%9A%84git%E7%BB%9F%E8%AE%A1%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">常见的git统计命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-12-18 11:31:30" itemprop="dateCreated datePublished" datetime="2019-12-18T11:31:30+08:00">2019-12-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-23 23:31:22" itemprop="dateModified" datetime="2021-10-23T23:31:22+08:00">2021-10-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E9%A1%B9/" itemprop="url" rel="index"><span itemprop="name">杂项</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近突然想看看自己对一个项目的贡献，打算总结常见的git统计命令，可以说对以前自己项目的一个回顾吧</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/12/18/%E5%B8%B8%E8%A7%81%E7%9A%84git%E7%BB%9F%E8%AE%A1%E5%91%BD%E4%BB%A4/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/11/19/Js%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/19/Js%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">Js对象模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-19 15:39:25" itemprop="dateCreated datePublished" datetime="2019-11-19T15:39:25+08:00">2019-11-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-23 23:31:22" itemprop="dateModified" datetime="2021-10-23T23:31:22+08:00">2021-10-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这篇文章主要总结了js中对象的创建方法 字面量创建、工厂模式、构造函数模式、原型模式、以及组合模式，以及js中继承的实现 原型链、经典继承、组合继承、拷贝继承、原型式继承、组合继承、ES6的extends继承等</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2019/11/19/Js%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F/">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/11/01/webpack%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/11/01/webpack%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">webpack性能优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-11-01 09:09:21" itemprop="dateCreated datePublished" datetime="2019-11-01T09:09:21+08:00">2019-11-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-23 23:31:22" itemprop="dateModified" datetime="2021-10-23T23:31:22+08:00">2021-10-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文根据经验总结了一些对于webpack的优化方法。分别从webpack打包前的构建优化(提高代码构建速度)。打包后的线上体验优化。参考并总结了现在常见的优化方法。希望以后可以提升webpack构建的项目性能。</p>
<h1 id="提高构建速度"><a href="#提高构建速度" class="headerlink" title="提高构建速度"></a>提高构建速度</h1><h2 id="减小编译范围"><a href="#减小编译范围" class="headerlink" title="减小编译范围"></a>减小编译范围</h2><p>缩小编译范围，减少不必要的编译工作，即 modules、mainFields、noParse、includes、exclude、alias全部用起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">const resolve = dir =&gt; path.join(__dirname, &#x27;..&#x27;, dir);</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">resolve: &#123;</span><br><span class="line">    modules: [ // 指定以下目录寻找第三方模块，避免webpack往父级目录递归搜索</span><br><span class="line">        resolve(&#x27;src&#x27;),</span><br><span class="line">        resolve(&#x27;node_modules&#x27;),</span><br><span class="line">        resolve(config.common.layoutPath)</span><br><span class="line">    ],</span><br><span class="line">    mainFields: [&#x27;main&#x27;], // 只采用main字段作为入口文件描述字段，减少搜索步骤</span><br><span class="line">    alias: &#123;</span><br><span class="line">        vue$: &quot;vue/dist/vue.common&quot;,</span><br><span class="line">        &quot;@&quot;: resolve(&quot;src&quot;) // 缓存src目录为@符号，避免重复寻址</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">module: &#123;</span><br><span class="line">    noParse: /jquery|lodash/, // 忽略未采用模块化的文件，因此jquery或lodash将不会被下面的loaders解析</span><br><span class="line">    // noParse: function(content) &#123;</span><br><span class="line">    //     return /jquery|lodash/.test(content)</span><br><span class="line">    // &#125;,</span><br><span class="line">    rules: [</span><br><span class="line">        &#123;</span><br><span class="line">            test: /\.js$/,</span><br><span class="line">            include: [ // 表示只解析以下目录，减少loader处理范围</span><br><span class="line">                resolve(&quot;src&quot;),</span><br><span class="line">                resolve(config.common.layoutPath)</span><br><span class="line">            ],</span><br><span class="line">            exclude: file =&gt; /test/.test(file), // 排除test目录文件</span><br><span class="line">            loader: &quot;happypack/loader?id=happy-babel&quot; // 后面会介绍</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="并发构建"><a href="#并发构建" class="headerlink" title="并发构建"></a>并发构建</h2><h3 id="terser-webpack-plugin"><a href="#terser-webpack-plugin" class="headerlink" title="terser-webpack-plugin"></a>terser-webpack-plugin</h3><p>压缩是构建中耗时占比较大的一环，我们可以启用 terser-webpack-plugin 的多线程压缩，减少压缩时间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">      new TerserJSPlugin(&#123;</span><br><span class="line">        parallel: true // 开启多线程压缩</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="webpack-parallel-uglify-plugin"><a href="#webpack-parallel-uglify-plugin" class="headerlink" title="webpack-parallel-uglify-plugin"></a>webpack-parallel-uglify-plugin</h3><p>实际上，搭载 webpack-parallel-uglify-plugin 插件，这个过程可以倍速提升。我们都知道 node 是单线程的，但node能够fork子进程，基于此，webpack-parallel-uglify-plugin 能够把任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进程，从而实现并发编译，进而大幅提升js压缩速度，如下是配置。<strong>多线程压缩</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const ParallelUglifyPlugin = require(&#x27;webpack-parallel-uglify-plugin&#x27;);</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">optimization: &#123;</span><br><span class="line">    minimizer: [</span><br><span class="line">        new ParallelUglifyPlugin(&#123; // 多进程压缩</span><br><span class="line">            cacheDir: &#x27;.cache/&#x27;,</span><br><span class="line">            uglifyJS: &#123;</span><br><span class="line">                output: &#123;</span><br><span class="line">                    comments: false,</span><br><span class="line">                    beautify: false</span><br><span class="line">                &#125;,</span><br><span class="line">                compress: &#123;</span><br><span class="line">                    wa  rnings: false,</span><br><span class="line">                    drop_console: true,</span><br><span class="line">                    collapse_vars: true,</span><br><span class="line">                    reduce_vars: true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;),</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h3><p>同 webpack-parallel-uglify-plugin 插件一样，HappyPack 也能实现并发编译，从而可以大幅提升 loader 的解析速度， 如下是部分配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const HappyPack = require(&#x27;happypack&#x27;);</span><br><span class="line">const happyThreadPool = HappyPack.ThreadPool(&#123; size: os.cpus().length &#125;);</span><br><span class="line">const createHappyPlugin = (id, loaders) =&gt; new HappyPack(&#123;</span><br><span class="line">    id: id,</span><br><span class="line">    loaders: loaders,</span><br><span class="line">    threadPool: happyThreadPool,</span><br><span class="line">    verbose: process.env.HAPPY_VERBOSE === &#x27;1&#x27; // make happy more verbose with HAPPY_VERBOSE=1</span><br><span class="line">&#125;);</span><br><span class="line">12345678</span><br></pre></td></tr></table></figure>

<p>那么，对于前面 <code>loader: &quot;happypack/loader?id=happy-babel&quot;</code> 这句，便需要在 plugins 中创建一个 <code>happy-babel</code> 的插件实例。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    createHappyPlugin(&#x27;happy-babel&#x27;, [&#123;</span><br><span class="line">        loader: &#x27;babel-loader&#x27;,</span><br><span class="line">        options: &#123;</span><br><span class="line">            babelrc: true,</span><br><span class="line">            cacheDirectory: true // 启用缓存</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;])</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>像 vue-loader、css-loader 都支持 happyPack 加速，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    createHappyPlugin(&#x27;happy-css&#x27;, [&#x27;css-loader&#x27;, &#x27;vue-style-loader&#x27;]),</span><br><span class="line">    new HappyPack(&#123;</span><br><span class="line">        loaders: [&#123;</span><br><span class="line">            path: &#x27;vue-loader&#x27;,</span><br><span class="line">            query: &#123;</span><br><span class="line">                loaders: &#123;</span><br><span class="line">                    scss: &#x27;vue-style-loader!css-loader!postcss-loader!sass-loader?indentedSyntax&#x27;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure>



<h2 id="noParse（无需解析内部依赖的包）"><a href="#noParse（无需解析内部依赖的包）" class="headerlink" title="noParse（无需解析内部依赖的包）"></a>noParse（无需解析内部依赖的包）</h2><p>对于我们引入的一些第三方包，比如<code>jQuery</code>，在这些包内部是肯定不会依赖别的包，所以根本不需要webpack去解析它内部的依赖关系，可以在<code>webpack</code>配置文件中的<code>module</code>属性下加上<code>noParse</code>属性，它的值是一个正则表达式，用来匹配无需解析的模块，这样可以节约<code>webpack</code>的打包时间，提高打包效率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module：&#123;</span><br><span class="line">    noParse：/jquery/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="DllPlugin-amp-DllReferencePlugin-提前打包公共依赖"><a href="#DllPlugin-amp-DllReferencePlugin-提前打包公共依赖" class="headerlink" title="DllPlugin &amp; DllReferencePlugin 提前打包公共依赖"></a>DllPlugin &amp; DllReferencePlugin 提前打包公共依赖</h2><p>我们都知道，webpack打包时，有一些框架代码是基本不变的，比如说 babel-polyfill、vue、vue-router、vuex、axios、element-ui、fastclick 等，这些模块也有不小的 size，每次编译都要加载一遍，比较费时费力。使用 DLLPlugin 和 DLLReferencePlugin 插件，便可以将这些模块提前打包。</p>
<p>当项目达到一定体量，打包速度、热加载性能优化的需求就会被提出来，毕竟谁也不愿意修改后花上十几秒甚至几分钟等待修改视图更新。接下里我会介绍一些通用的优化策略，但需要注意的是，项目本身不能去踩一些无法优化的坑，已知两坑：超多页（ html-webpack-plugin 热更新时更新所有页面）和动态加载未指明明确路径（打包目录下所有页面）。</p>
<p>DllPlugin 和 DllReferencePlugin 绝对是优化打包速度的最佳利器，它可以把部分公共依赖提前打包好，在之后的打包中就不再打包这些依赖而是直接取用已经打包好的代码，通常情况能降低 20% ~ 40% 打包时间，当然它也有缺点：</p>
<ul>
<li>需要在初始化和相关依赖更新时，额外执行一条命令</li>
<li>通常 dll 是在 <code>.html</code> 文件中引入，滥用会导致首屏加载变慢</li>
</ul>
<p>但总归来说是利大于弊。</p>
<p>为了完成 dll 过程，我们需要准备一份新的webpack配置，即 webpack.dll.config.js。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const webpack = require(&quot;webpack&quot;);</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line">const CleanWebpackPlugin = require(&quot;clean-webpack-plugin&quot;);</span><br><span class="line">const dllPath = path.resolve(__dirname, &quot;../src/assets/dll&quot;); // dll文件存放的目录</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        // 把 vue 相关模块的放到一个单独的动态链接库</span><br><span class="line">        vue: [&quot;babel-polyfill&quot;, &quot;fastclick&quot;, &quot;vue&quot;, &quot;vue-router&quot;, &quot;vuex&quot;, &quot;axios&quot;, &quot;element-ui&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &quot;[name]-[hash].dll.js&quot;, // 生成vue.dll.js</span><br><span class="line">        path: dllPath,</span><br><span class="line">        library: &quot;_dll_[name]&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        new CleanWebpackPlugin([&quot;*.js&quot;], &#123; // 清除之前的dll文件</span><br><span class="line">            root: dllPath,</span><br><span class="line">        &#125;),</span><br><span class="line">        new webpack.DllPlugin(&#123;</span><br><span class="line">            name: &quot;_dll_[name]&quot;,</span><br><span class="line">            // manifest.json 描述动态链接库包含了哪些内容</span><br><span class="line">            path: path.join(__dirname, &quot;./&quot;, &quot;[name].dll.manifest.json&quot;)</span><br><span class="line">        &#125;),</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br><span class="line">1234567891011121314151617181920212223242526</span><br></pre></td></tr></table></figure>

<p>接着， 需要在 package.json 中新增 dll 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dll&quot;: &quot;webpack --mode production --config build/webpack.dll.config.js&quot;</span><br><span class="line">&#125;</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>运行 <code>npm run dll</code> 后，会生成 <code>./src/assets/dll/vue.dll-[hash].js</code> 公共js 和 <code>./build/vue.dll.manifest.json</code> 资源说明文件，至此 dll 准备工作完成，接下来在 webpack 中引用即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">    &#x27;vue&#x27;: &#x27;Vue&#x27;,</span><br><span class="line">    &#x27;vue-router&#x27;: &#x27;VueRouter&#x27;,</span><br><span class="line">    &#x27;vuex&#x27;: &#x27;vuex&#x27;,</span><br><span class="line">    &#x27;elemenct-ui&#x27;: &#x27;ELEMENT&#x27;,</span><br><span class="line">    &#x27;axios&#x27;: &#x27;axios&#x27;,</span><br><span class="line">    &#x27;fastclick&#x27;: &#x27;FastClick&#x27;</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">    ...(config.common.needDll ? [</span><br><span class="line">        new webpack.DllReferencePlugin(&#123;</span><br><span class="line">            manifest: require(&quot;./vue.dll.manifest.json&quot;)</span><br><span class="line">        &#125;)</span><br><span class="line">    ] : [])</span><br><span class="line">]</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure>

<p>dll 公共js轻易不会变化，假如在将来真的发生了更新，那么新的dll文件名便需要加上新的hash，从而避免浏览器缓存老的文件，造成执行出错。由于 hash 的不确定性，我们在 html 入口文件中没办法指定一个固定链接的 script 脚本，刚好，add-asset-html-webpack-plugin 插件可以帮我们自动引入 dll 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const autoAddDllRes = () =&gt; &#123;</span><br><span class="line">    const AddAssetHtmlPlugin = require(&#x27;add-asset-html-webpack-plugin&#x27;);</span><br><span class="line">    return new AddAssetHtmlPlugin([&#123; // 往html中注入dll js</span><br><span class="line">        publicPath: config.common.publicPath + &quot;dll/&quot;,  // 注入到html中的路径</span><br><span class="line">        outputPath: &quot;dll&quot;, // 最终输出的目录</span><br><span class="line">        filepath: resolve(&quot;src/assets/dll/*.js&quot;),</span><br><span class="line">        includeSourcemap: false,</span><br><span class="line">        typeOfAsset: &quot;js&quot; // options js、css; default js</span><br><span class="line">    &#125;]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">plugins: [</span><br><span class="line">    ...(config.common.needDll ? [autoAddDllRes()] : [])</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="生成合理的-Source-Map"><a href="#生成合理的-Source-Map" class="headerlink" title="生成合理的 Source Map"></a>生成合理的 Source Map</h2><p>在 webpack 4 中，是否生成 Source Map 以及生成怎样的 Source Map 是由 <code>devtool</code> 配置控制的，选择合理的 Source Map 可以有效的缩短打包时间。在选择前我们还是应该明白，不设置 Source Map 时打包是最快的，之所以需要 Source Map ，是因为打包后的代码结构、文件名和打包前完全不一致，当存在报错时我们只能直接定位到打包后的某个文件，无法定位到源文件，极大程度增加了调试难度。而 Source Map 就是为了增强打包后代码的可调试性而存在的，所以我们在开发环境总是需要它，在生产环境则有更多选择。</p>
<p><code>devtool</code> 可选配置有 <code>none</code> 、 <code>eval</code> 、 <code>cheap-eval-source-map</code> 等 13 种，各自功能和性能比较在 <a target="_blank" rel="noopener" href="https://webpack.docschina.org/configuration/devtool/">文档</a> 中有详细介绍。</p>
<p>配置项由一个或多个单词和连字符组成，每个单词都有其含义和性能损耗，每个配置项最终意义就由这些单词决定：</p>
<ul>
<li><code>none</code> 不生成 Source Map ，性能 +++</li>
<li><code>eavl</code> 每个模块由 <code>eval</code> 执行，不能正确显示行数，不能用生产模式，性能 +++</li>
<li><code>module</code> 报错显示原始代码，性能 -</li>
<li><code>source</code> 报错显示行列信息，显示 babel 转译后代码，性能 –</li>
<li><code>cheap</code> 低开销模式，不映射列，性能 +</li>
<li><code>inline</code> 不生成单独的 Source Map 文件，性能 o</li>
</ul>
<h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><p>由于开发模式建议显示报错源码和行信息，所以 <code>module</code> 和 <code>source</code> 都是需要的，为了性能我们又需要 <code>eval</code> 和 <code>cheap</code> ，所以参照配置项能找到最适合开发环境的配置是 <code>devtool: cheap-module-eval-source-map</code> 。</p>
<h4 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h4><p>生产环境由于几乎不存在调试需求（ JS 相关调试），所以建议大家设置 <code>devtool: none</code> ，在需要调试的时候再更改设置为 <code>devtool: cheap-module-source-map</code> 。</p>
<p>分别配置 mode属性，设置为 <code>development</code> 将获得最好的开发体验，设置为 <code>production</code> 将专注项目编译部署，比如说开启 Scope hoisting 和 Tree-shaking 功能。</p>
<h1 id="线上环境用户体验优化"><a href="#线上环境用户体验优化" class="headerlink" title="线上环境用户体验优化"></a>线上环境用户体验优化</h1><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>Vue  是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。</p>
<p><strong>路由懒加载：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Foo = () =&gt; import(&#x27;./Foo.vue&#x27;)</span><br><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; path: &#x27;/foo&#x27;, component: Foo &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="组件异步加载"><a href="#组件异步加载" class="headerlink" title="组件异步加载"></a>组件异步加载</h2><p>如果组件在页面加载时不需要，只在调用时用到，这时可以使用异步组件的写法。仅仅是引入和组件注册写法不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// template</span><br><span class="line">&lt;test v-if=&quot;showTest&quot;&gt;&lt;/test&gt;</span><br><span class="line"></span><br><span class="line">// script</span><br><span class="line">  components: &#123;</span><br><span class="line">    test: () =&gt; import(&#x27;./test&#x27;) // 将组件异步引入，告诉webpack，将该部分代码分割打包</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">      clickTest () &#123;</span><br><span class="line">          this.showTest = !this.showTest</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="魔法注释"><a href="#魔法注释" class="headerlink" title="魔法注释"></a>魔法注释</h2><p>在懒加载的同时可以使用魔法注释：<code>Prefetching</code>，可以在首页资源加载完毕后，<strong>空闲时间时，将动态导入的资源加载进来</strong>，这样即可以提高页面加载速度又保证了用户体验。(感觉有点类似于h2的主动推送)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Foo = () =&gt; import(/* webpackChunkName: &quot;group-foo&quot; */ &#x27;./Foo.vue&#x27;)</span><br></pre></td></tr></table></figure>



<h2 id="代码优化-压缩"><a href="#代码优化-压缩" class="headerlink" title="代码优化 压缩"></a>代码优化 压缩</h2><p>vue-cli已经使用UglifyJsPlugin 插件来压缩代码，可以设置成如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">  compress: &#123;</span><br><span class="line">    warnings: false,</span><br><span class="line">    drop_console: true,</span><br><span class="line">    pure_funcs: [&#x27;console.log&#x27;]</span><br><span class="line">  &#125;,</span><br><span class="line">  sourceMap: false</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h2 id="代码分离-SplitChunksPlugin"><a href="#代码分离-SplitChunksPlugin" class="headerlink" title="代码分离(SplitChunksPlugin)"></a>代码分离(SplitChunksPlugin)</h2><p>代码分离有两个优点：</p>
<ul>
<li><p>剥离公共代码和依赖，避免重复打包</p>
</li>
<li><p>避免单个文件体积过大</p>
<p>总加载体积一致，浏览器加载多个文件通常快于单个文件</p>
</li>
</ul>
<p>为了解决公共资源被重复打包问题，我们就需要 <a target="_blank" rel="noopener" href="https://webpack.docschina.org/plugins/split-chunks-plugin/">SplitChunksPlugin</a> 的帮助，它可以把代码分离成不同的 bundle ，在页面需要时被加载。另外 SplitChunksPlugin 是 webpack 4 的内置插件，所以我们不需要去独立安装它。</p>
<p>使用方法：只需在主配置文件中添加如下配置即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">        Chunks: &#x27;all&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree shaking"></a>tree shaking</h2><p>上面我们分离代码，解决了项目中部分代码被重复打包到多个生成物中的问题，有效地缩小了生成物体积，但其实我们还可以在此基础上进一步缩小体积，这就涉及本小节的概念 tree shaking 。</p>
<blockquote>
<p>tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块语法的 静态结构 特性，例如 import 和 export。</p>
</blockquote>
<blockquote>
<p>你可以将应用程序想象成一棵树。绿色表示实际用到的 source code(源码) 和 library(库)，是树上活的树叶。灰色表示未引用代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。</p>
</blockquote>
<p>我们回头看在使用 SplitChunksPlugin 时生成的文件，可以发现 <code>say</code> 函数没有使用但是却被打包进来了，它实际上是无用的代码，也就是文档中说的 dead-code 。要删除这些代码，只需要把 <code>mode</code> 修改为 <code>production</code> （让 tree shaking 生效），再次打包~</p>
<p>不过需要注意的是， tree shaking 能移除无用代码的同时，也有一定的副作用（错误识别无用代码）。比如你可能会遇到 <strong>UI 组件库没有样式</strong>的问题，这个问题原因在于 tree shaking 不仅对 JS 生效，也对 CSS 生效 。我们通常在导入 CSS 时使用 <code>import &#39;xxx.min.css&#39;</code> ， ES6 的静态导入 + 生产环境满足了 tree shaking 的生效条件，并且 Webpack 无法判断 CSS 有效，所以它被当做了 dead-code 然后被删除。为了解决这个问题，你可以在 <code>package.json</code> 中添加一个 <code>sideEffects</code> 选项，告知 Webpack 那些文件是可以直接引入而不用 tree shaking 检查的，使用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;sideEffects&quot;: [</span><br><span class="line">    &quot;*.css&quot;,</span><br><span class="line">    &quot;*.styl(us)?&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="cdn加速"><a href="#cdn加速" class="headerlink" title="cdn加速"></a>cdn加速</h2><p>浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。</p>
<p>或者直接开启<strong>全站加速</strong>服务。对你部署的域名或者ip进行加速，无需对服务器源站上的资源进行改造，全站加速会智能区分动静态内容并分别加速。整个网站的资源访问速度都会大大加快。</p>
<h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d68d6b0e51d4561a60d9e1c?utm_source=gold_browser_extension">webpack优化的一些基本方法</a></p>
<p><a target="_blank" rel="noopener" href="http://louiszhai.github.io/2019/01/04/webpack4/">使用webpack4提升180%编译速度</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b652b036fb9a04fa01d616b">三十分钟掌握Webpack性能优化</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/10/21/%E5%AE%B6%E5%9B%AD%E5%B7%A5%E4%BD%9C%E5%AE%A4%E9%A1%B9%E7%9B%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9(%E5%B7%A5%E4%BD%9C%E6%B5%81)-%E6%96%B0%E4%BA%BA%E5%BF%85%E8%AF%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/21/%E5%AE%B6%E5%9B%AD%E5%B7%A5%E4%BD%9C%E5%AE%A4%E9%A1%B9%E7%9B%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9(%E5%B7%A5%E4%BD%9C%E6%B5%81)-%E6%96%B0%E4%BA%BA%E5%BF%85%E8%AF%BB/" class="post-title-link" itemprop="url">家园工作室项目注意事项(工作流)-新人必读</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-21 20:53:28" itemprop="dateCreated datePublished" datetime="2019-10-21T20:53:28+08:00">2019-10-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-23 23:31:22" itemprop="dateModified" datetime="2021-10-23T23:31:22+08:00">2021-10-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>项目创建、数据埋点、监控埋点、代码规范、工作流、项目进度、上线部署、文档、项目存档(语雀)、监控、数据分析、交接。</p>
<p>恭喜你！如果你能独立负责一个项目，证明你已经有独挡一面的能力了。接下来请仔细阅读该文档。做好独立负责一个项目的准备吧！</p>
<h2 id="前置知识，秘钥配置"><a href="#前置知识，秘钥配置" class="headerlink" title="前置知识，秘钥配置"></a>前置知识，秘钥配置</h2><p>你需要把你的秘钥，上传到我们的gitlab上。</p>
<p><img src="http://cetquery.flura.cn/1571650392063.png" alt="1571650392063"></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/popfisher/p/5731232.html">ssh配置参考教程</a></p>
<h2 id="项目新建"><a href="#项目新建" class="headerlink" title="项目新建"></a>项目新建</h2><p>我们工作室所有的项目基本上都是保存在我们自己内部的gitlab上的。<a target="_blank" rel="noopener" href="https://git.ncuos.com/">https://git.ncuos.com</a>   ps: 你需要被邀请加入项目组</p>
<p>创建项目在projects里点击新建new project后将会出现以下界面。</p>
<p><img src="http://img.flura.cn/1571382102230.png" alt="1571382102230"></p>
<p><img src="http://img.flura.cn/1571381776046.png" alt="1571381776046"></p>
<p>一般项目都会选择在dev组里新建，这样你的代码方便所有人进行查看。但是，因为gitlab具有严格的权限管理，一般来说这个时候你是没有Maintainer及以上权限的。所以你最好在User组新建 任意等级的项目(这是自己的私人项目)。然后<strong>一定要在 Setting    Members     invite group里邀请dev项目组的成员</strong> 这样别人就能看到你的项目，并参与开发了。</p>
<p><img src="http://img.flura.cn/1571383767650.png" alt="1571383767650"></p>
<p>接下来就和github新建了项目一样了。</p>
<h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>为了提高可维护性、可阅读性。我们的项目统一采用了lint规范。所以必须上lint进行开发项目。</p>
<p>git规范： <a target="_blank" rel="noopener" href="https://yanshuo.io/assets/player/?deck=58f7703ba22b9d006c15edee&amp;tdsourcetag#/">https://yanshuo.io/assets/player/?deck=58f7703ba22b9d006c15edee&amp;tdsourcetag#/</a></p>
<p>技术文档规范： <a target="_blank" rel="noopener" href="https://github.com/ruanyf/document-style-guide">https://github.com/ruanyf/document-style-guide</a></p>
<p>前端代码规范： <a target="_blank" rel="noopener" href="https://ncuhome.github.io/frontend-guide/">https://ncuhome.github.io/frontend-guide/</a></p>
<p>后端代码规范：</p>
<h2 id="数据埋点"><a href="#数据埋点" class="headerlink" title="数据埋点"></a>数据埋点</h2><p>我们的数据埋点，采用的是Google Analytics的埋点。<a target="_blank" rel="noopener" href="https://analytics.google.com/">GoogleAnalytics</a>   所以如果你的项目要面对大流量、之后再进行大数据分析的话，你要联系学长创建 对应你项目的埋点(我们的hanalytics.google 有个组织 Ncuhome，历史的埋点数据都会被集中在里面，以便进行分析)。一般联系你项目对应的产品经理或组长。 </p>
<p><img src="http://img.flura.cn/1571403457667.png" alt="控制台参考图"></p>
<p>将生成的跟踪代码 放入你的前端页面，就能实现数据收集功能。 Google Analytics 会生成可视化的视图提供你分析。 </p>
<h2 id="监控埋点"><a href="#监控埋点" class="headerlink" title="监控埋点"></a>监控埋点</h2><p>Sentry是一个实时事件日志记录和汇集的平台。其专注于错误监控以及提取一切事后处理所需信息而不依赖于麻烦的用户反馈。它分为客户端和服务端，客户端(目前客户端有Python,js)就嵌入在你的应用程序中间，程序出现异常就向服务端发送消息，服务端将消息记录到数据库中并提供一个web页方便查看。Sentry由python编写，源码开放，性能卓越，易于扩展 。 <a target="_blank" rel="noopener" href="http://sentry.ncuos.com/">http://sentry.ncuos.com</a> 这是我们的sentry，如果的项目需要长时间在线上环境运行，进行线上环境监控是非常有必要的。 创建你项目对应的sentry，然后进行埋点。教程参考下面的链接。</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000014496409">Sentry异常监控方案部署-前端攻略</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/66e00077fac3">sentry使用实践</a></p>
<p>一般重要项目出现服务宕机，会有报警电话(大公司架构)。我们可以配置报警邮件，及时去恢复服务。避免消耗用户的信任。</p>
<h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>我们的git工作流程 采用的是企业级gitflow工作流。</p>
<p><strong>master 分支</strong></p>
<p>master分支上存放的应该是随时可供在生产环境中部署的代码（Production Ready state）。当开发活动告一段落，产生了一份新的可供部署的代码时，master分支上的代码会被更新。</p>
<p><strong>本地分支</strong></p>
<p>在本地创建的开发分支，开发完毕后，将该分支push到我们的gitlab上。 然后线上在 你的分支上提交merge request  (提交后记得通知你的学长，让他merge你的commit)， 代码经过上级的code review后会merge进入maser分支中。这时你的任务完成。</p>
<h2 id="上线部署"><a href="#上线部署" class="headerlink" title="上线部署"></a>上线部署</h2><p>我们的项目目前主要方向都是用CI部署模式，代码被merge入master分支，Travis脚本自动执行，gitlab-ci自动build部署到生产环境。</p>
<p>前端项目建议部署到阿里云的对象存储(OSS)上。访问速度快、无带宽限制，上行流量免费，无需运维人员与托管费用，0成本运维。</p>
<p>后端项目： 后端部署一般需要申请服务器，部署在我们家园自己的服务器上。(其实一般应该直接买一台学生机，练练怎么部署项目) </p>
<h3 id="部署规范"><a href="#部署规范" class="headerlink" title="部署规范"></a>部署规范</h3><p><strong>项目部署位置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/www/project_name</span><br></pre></td></tr></table></figure>

<p>请将所有的项目部署在这个文件夹内，并且要求项目名清晰明了。  </p>
<p>Lxxyx学长在2016年写了一份<a target="_blank" rel="noopener" href="http://blog.ncuos.com/xiang-mu-ji-dai-ma-bu-shu-gui-fan/">项目及代码部署规范</a>，在这里强调一下部署的规范和一些运维的要求，希望能为后来人的工作提供一点帮助。</p>
<h3 id="项目部署方法"><a href="#项目部署方法" class="headerlink" title="项目部署方法"></a>项目部署方法</h3><p>家园即将用上K8S，但在这里还是以Docker部署为主，待到之后更新了K8S在来更新这份文档。</p>
<p>使用Dockerfile和 .dockerignore 定义镜像，使用docker-compose.yml定义容器，在这里指定开放端口，数据卷等，docker-compose管理容器启动，关闭，重启。</p>
<h3 id="日志存放位置"><a href="#日志存放位置" class="headerlink" title="日志存放位置"></a>日志存放位置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/var/log/project_name</span><br></pre></td></tr></table></figure>

<p>使用docker-compose.yml将日志挂载在对应的项目日志文件夹。</p>
<p>项目的日志文件以及报错信息需要按照项目存放，方便查找和处理。</p>
<p>除了容器产生的日志，如果需要使用到nginx的日志功能，将该server产生的日志也存放于此。</p>
<h3 id="Docker容器大小"><a href="#Docker容器大小" class="headerlink" title="Docker容器大小"></a>Docker容器大小</h3><p>因为服务器容量有被全部占用完全，导致服务无法正常提供，持续删日志的经历，也为了防止因错误原因持续产生垃圾日志导致服务器别完全占用，请为docker-compose.yml内所有的server加上：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line">	<span class="attr">driver:</span> <span class="string">&quot;json-file&quot;</span> <span class="string">//</span> <span class="string">可自行选择</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">		<span class="attr">max-size:</span> <span class="string">&quot;50m&quot;</span> <span class="string">//</span> <span class="string">可选</span></span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="服务器申请"><a href="#服务器申请" class="headerlink" title="服务器申请"></a>服务器申请</h3><p>我们的服务器申请有自己的一套流程，只需要在  <a target="_blank" rel="noopener" href="https://git.ncuos.com/dev/devops">服务器配置</a> 里按照文档添加你的秘钥，你就能获得对应的服务器。申请服务器之前，请先询问你的学长，你能使用哪台服务器。</p>
<h3 id="关于服务器账户"><a href="#关于服务器账户" class="headerlink" title="关于服务器账户"></a>关于服务器账户</h3><p>介于此时工作室的体量以及组织情况，目前服务器只需要一个开发用户dev，不需要其他的<strong>个人账户</strong>。</p>
<p>该dev用户拥有<code>sudo</code>权限，所以请在使用该用户时不要进行<strong>危险操作</strong>。</p>
<p>为了方便管理和安全，dev不允许密码登陆，需要使用服务器或部署项目的人需向管理员申请，管理员使用工作室专用的管理项目进行配置。</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>请注意，<strong>每个项目都必须留存有文档</strong>，最起码要介绍一下这个项目是做什么用的，部署在什么地方，还有接口文档、这个项目里有什么注意的地方，有什么要给后来的人交代的地方。</p>
<h2 id="项目存档"><a href="#项目存档" class="headerlink" title="项目存档"></a>项目存档</h2><p>每个项目必须在语雀上留有存档、该存档一般由项目组成员共同编写。开发如果把文档写好了，只要简单改动下就可以保存在语雀上了。<a target="_blank" rel="noopener" href="https://www.yuque.com/">语雀</a></p>
<h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>你埋点的东西终于有了回报，看着有那么多人使用你开发的产品，你会有自豪感的!!  可以观察一下某些趋势，写入文档中，尤其是如果某些周期性项目(每年都要做的四六级查询等)，一些用户数据存档是非常重要的。</p>
<p><a target="_blank" rel="noopener" href="https://analytics.google.com/">https://analytics.google.com</a></p>
<h2 id="项目交接"><a href="#项目交接" class="headerlink" title="项目交接"></a>项目交接</h2><p>交接方面，一般如果你的项目有了继续迭代下去的需求，就必须考虑传承的问题了。如果你前面的文档写的不错，项目存档做的很好，这个不成问题了，如果做的不好，那请回去补全你的文档。那么以后下一批交接的人如果有问题找你，你只需要在空闲时间抽出时间回复学弟学妹问题就好了。</p>
<p>请对你的用户负责，对你的项目负责，也对你自己负责。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/10/10/%E5%AE%B6%E5%9B%AD%E5%B7%A5%E4%BD%9C%E5%AE%A4%E6%96%B0%E4%BA%BA%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9F%B9%E8%AE%AD(%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%85%A5%E9%97%A8)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/10/%E5%AE%B6%E5%9B%AD%E5%B7%A5%E4%BD%9C%E5%AE%A4%E6%96%B0%E4%BA%BA%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9F%B9%E8%AE%AD(%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%85%A5%E9%97%A8)/" class="post-title-link" itemprop="url">家园工作室新人第一次培训(计算机入门)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-10 22:58:57" itemprop="dateCreated datePublished" datetime="2019-10-10T22:58:57+08:00">2019-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-23 23:31:22" itemprop="dateModified" datetime="2021-10-23T23:31:22+08:00">2021-10-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E9%A1%B9/" itemprop="url" rel="index"><span itemprop="name">杂项</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="计算机杂谈"><a href="#计算机杂谈" class="headerlink" title="计算机杂谈"></a>计算机杂谈</h2><h3 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h3><p><img src="http://img.flura.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90.png" alt="计算机组成"></p>
<p>计算机硬件系统的基本组成及工作原理<br>⑴ 计算机硬件由五个基本部分组成：运<strong>算器、控制器、存储器、输入设备和输出设备。</strong><br>⑵ 计算机内部采用<strong>二进制</strong>来表示程序和数据。<br>⑶ 采用“存储程序”的方式，将程序和数据放入同一个存储器中（内存储器），计算机能够自动高速地从存储器中取出指令加以执行。<br>可以说计算机硬件的五大部件中每一个部件都有相对独立的功能，分别完成各自不同的工作。如图1-7所示，五大部件实际上是在控制器的控制下协调统一地工作。首先，把表示计算步骤的程序和计算中需要的原始数据，在控制器输入命令的控制下，通过输入设备送入计算机的存储器存储。其次当计算开始时，在取指令作用下把程序指令逐条送入控制器。控制器对指令进行译码，并根据指令的操作要求向存储器和运算器发出存储、取数命令和运算命令，经过运算器计算并把结果存放在存储器内。在控制器的取数和输出命令作用下，通过输出设备输出计算结果。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sunshine_hsm/article/details/81536509">计算机的基本组成和工作原理</a></p>
<p><img src="http://img.flura.cn/1496915188338.png" alt="1496915188338"></p>
<p><img src="http://img.flura.cn/1497317567484.png" alt="1497317567484"></p>
<p><img src="http://img.flura.cn/%E7%A1%AC%E4%BB%B6%E4%B8%BB%E6%9D%BF.png" alt="硬件主板"></p>
<p><img src="http://img.flura.cn/jianpan-2.png" alt="敲键盘姿势"></p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><h4 id="查看本机基本配置"><a href="#查看本机基本配置" class="headerlink" title="查看本机基本配置"></a>查看本机基本配置</h4><p><a target="_blank" rel="noopener" href="http://www.xitongcheng.com/jiaocheng/xtazjc_article_29281.html">怎么查自己电脑的配置</a></p>
<h4 id="查看隐藏文件、修改文件扩展名。"><a href="#查看隐藏文件、修改文件扩展名。" class="headerlink" title="查看隐藏文件、修改文件扩展名。"></a>查看隐藏文件、修改文件扩展名。</h4><p><img src="http://img.flura.cn/1570599578880.png" alt="1570599578880"></p>
<h4 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h4><p>打开控制面板  程序  卸载程序   找到你要卸载的程序卸载就行了。</p>
<h4 id="强制关闭程序"><a href="#强制关闭程序" class="headerlink" title="强制关闭程序"></a>强制关闭程序</h4><p>打开任务管理器 Ctrl+Shift+Esc  找到你要关闭的(进程)程序，点击结束任务。</p>
<h4 id="window简单快捷键"><a href="#window简单快捷键" class="headerlink" title="window简单快捷键"></a>window简单快捷键</h4><p><img src="http://img.flura.cn/kuaijiejian-3.png" alt="kuaijiejian-3"></p>
<h4 id="推荐基本工具"><a href="#推荐基本工具" class="headerlink" title="推荐基本工具"></a>推荐基本工具</h4><p><strong>notepad++</strong>  </p>
<p>NOTEPAD++是一款免费又优秀的文本编辑器，支持在 MS Windows 环境下运行的多种编程语言。NOTEPAD++支持超过 50 种编程、脚本和标记语言的语法高亮显示和代码折叠，能让用户迅速减小或扩大代码段以便查阅整个文档。用户也可以手动设置当前语言，覆盖默认语言。该程序还支持自动完成某些编程语言的 API 子集。</p>
<p>官方网站：<a target="_blank" rel="noopener" href="http://notepad-plus-plus.org/">http://notepad-plus-plus.org</a></p>
<p><strong>Typora</strong>   Markdown文本编辑器 <a target="_blank" rel="noopener" href="https://sspai.com/post/54912">Typora 完全使用详解</a></p>
<p><strong>代码编辑器</strong>  <strong>VS Code</strong> <a target="_blank" rel="noopener" href="https://code.visualstudio.com/">https://code.visualstudio.com</a>     <strong>subline text3</strong></p>
<p><strong>IDE</strong>       <strong>WebStorm</strong>      <strong>PyCharm</strong>    <strong>IntelliJ IDEA</strong>       <a target="_blank" rel="noopener" href="https://www.jetbrains.com/">https://www.jetbrains.com</a>     ps:  jetbrains家族的东西都是要收费的(有一个月试用期，适用完毕开始收费)。所以需要在学校的官网申请教育邮箱 .edu结尾的邮箱， 然后用这个邮箱到  <a target="_blank" rel="noopener" href="https://www.jetbrains.com/">jetbrains</a> 官网注册学生账号，可以免费使用该产品。</p>
<p><strong>浏览器</strong>  <strong>Chrome  FireFox</strong> </p>
<p><strong>Git</strong>  Git官方网站：<a target="_blank" rel="noopener" href="https://git-scm.com/">https://git-scm.com</a></p>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="从浏览器地址栏输入网址，到网页彻底打开，中间都发生了什么？"><a href="#从浏览器地址栏输入网址，到网页彻底打开，中间都发生了什么？" class="headerlink" title="从浏览器地址栏输入网址，到网页彻底打开，中间都发生了什么？"></a>从浏览器地址栏输入网址，到网页彻底打开，中间都发生了什么？</h3><ul>
<li>DNS 解析:将域名解析成 IP 地址</li>
<li>TCP 连接：TCP 三次握手</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>断开连接：TCP 四次挥手</li>
</ul>
<p><strong>URL</strong>    </p>
<p>什么是URL？</p>
<p><strong>URL指的是统一资源定位符（</strong><em>Uniform Resource Locator</em><strong>）</strong>。URL无非就是一个给定的独特资源在Web上的地址。</p>
<p>一个URL由不同的部分组成，其中一些是必须的，而另一些是可选的。让我们以下面这个URL为例看看其中最重要的部分：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com:80/path/to/myfile.html?key1=value1&amp;key2=value2#SomewhereInTheDocument</span><br></pre></td></tr></table></figure>

<ul>
<li><p><img src="https://mdn.mozillademos.org/files/8013/mdn-url-protocol@x2.png" alt="Protocol"></p>
<p><code>http://</code> 是协议。它表明了浏览器必须使用何种协议。它通常都是HTTP协议或是HTTP协议的安全版，即HTTPS。Web需要它们二者之一，但浏览器也知道如何处理其他协议，比如<code>mailto:（打开邮件客户端）或者 ``ftp:（处理文件传输），所以当你看到这些协议时，不必惊讶。</code></p>
</li>
<li><p><img src="https://mdn.mozillademos.org/files/8015/mdn-url-domain@x2.png" alt="Domaine Name"></p>
<p><code>www.example.com</code> 是域名。 它表明正在请求哪个Web服务器。或者，可以直接使用<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Glossary/IP_address">IP address</a>, 但是因为它不太方便，所以它不经常在网络上使用。.</p>
</li>
<li><p><img src="https://mdn.mozillademos.org/files/8017/mdn-url-port@x2.png" alt="Port"></p>
<p><code>:80</code> 是端口。 它表示用于访问Web服务器上的资源的技术“门”。如果Web服务器使用HTTP协议的标准端口（HTTP为80，HTTPS为443）来授予其资源的访问权限，则通常会被忽略。否则是强制性的。</p>
</li>
<li><p><img src="https://mdn.mozillademos.org/files/8019/mdn-url-path@x2.png" alt="Path to the file"></p>
<p><code>/path/to/myfile.html</code> 是网络服务器上资源的路径。在Web的早期阶段，像这样的路径表示Web服务器上的物理文件位置。如今，它主要是由没有任何物理现实的Web服务器处理的抽象。</p>
</li>
<li><p><img src="https://mdn.mozillademos.org/files/8021/mdn-url-parameters@x2.png" alt="Parameters"></p>
<p><code>?key1=value1&amp;key2=value2</code> 是提供给网络服务器的额外参数。 这些参数是用 <code>&amp; </code>符号分隔的键/值对列表。在返回资源之前，Web服务器可以使用这些参数来执行额外的操作。每个Web服务器都有自己关于参数的规则，唯一可靠的方式来知道特定Web服务器是否处理参数是通过询问Web服务器所有者。</p>
</li>
<li><p><img src="https://mdn.mozillademos.org/files/8023/mdn-url-anchor@x2.png" alt="Anchor"></p>
<p><code>#SomewhereInTheDocument</code> 是资源本身的另一部分的锚点. 锚点表示资源中的一种“书签”，给浏览器显示位于该“加书签”位置的内容的方向。例如，在HTML文档上，浏览器将滚动到定义锚点的位置;在视频或音频文档上，浏览器将尝试转到锚代表的时间。值得注意的是，＃后面的部分（也称为片段标识符）从来没有发送到请求的服务器。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/Common_questions/What_is_a_URL">什么是URL？</a></p>
<p><strong>浏览器解析渲染页面</strong></p>
<p><img src="http://img.flura.cn/1456355-8883dbd15f39cc18.webp" alt="1456355-8883dbd15f39cc18"></p>
<p><strong>解析后生成的DOM树</strong></p>
<p><img src="http://img.flura.cn/1497169919418.png" alt="1497169919418"></p>
<h3 id="常见的浏览器软件包括："><a href="#常见的浏览器软件包括：" class="headerlink" title="常见的浏览器软件包括："></a>常见的浏览器软件包括：</h3><ul>
<li>Google的Chrome。Webkit内核（新版转向Blink）和V8 JS引擎</li>
<li>微软的IE。Trident内核，IE 11之后不再更新。</li>
<li>微软的Edge。EdgeHTML内核，Chakra JS引擎。</li>
<li>Mozilla的Firefox。Gecko内核和 SpiderMonkey JS引擎。</li>
<li>苹果的Safari。Webkit内核，Nitro JS引擎。</li>
<li>Opera。原Presto，新版也转向Blink和V8。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.search1990.com/other/201611200936.html">2018年11月，全球&amp;国内浏览器市场份额排行榜</a></p>
<h3 id="搜索引擎使用-搜索技巧"><a href="#搜索引擎使用-搜索技巧" class="headerlink" title="搜索引擎使用(搜索技巧)"></a>搜索引擎使用(搜索技巧)</h3><p>1、双引号</p>
<p>把搜索词放在双引号中，代表完全匹配搜索，也就是说搜索结果返回的页面包含双引号中出现的所有的词，连顺序也必须完全匹配。bd和Google 都支持这个指令。例如搜索： “seo方法图片”</p>
<p>2、减号</p>
<p>减号代表搜索不包含减号后面的词的页面。使用这个指令时减号前面必须是空格，减号后面没有空格，紧跟着需要排除的词。Google 和bd都支持这个指令。<br>例如：搜索 -引擎<br>返回的则是包含“搜索”这个词，却不包含“引擎”这个词的结果</p>
<p>3、星号<br>星号<em>是常用的通配符，也可以用在搜索中。百度不支持</em>号搜索指令。<br>比如在Google 中搜索：搜索<em>擎<br>其中的</em>号代表任何文字。返回的结果就不仅包含“搜索引擎”，还包含了“搜索收擎”，“搜索巨擎”等内容。</p>
<p>4、site<br>site:是SEO 最熟悉的高级搜索指令，用来搜索某个域名下的所有文件。</p>
<p>site:<a target="_blank" rel="noopener" href="http://www.yuque.com/">www.yuque.com</a></p>
<p>5、related<br>related:指令只适用于Google，返回的结果是与某个网站有关联的页面。比如搜索</p>
<p>related:<a target="_blank" rel="noopener" href="http://www.ncu.edu.cn/">www.ncu.edu.cn</a></p>
<p>6、filetype<br>用于搜索特定文件格式。Google 和bd都支持filetype 指令。<br>比如搜索 </p>
<p>SEO filetype:pdf<br>返回的就是包含SEO 这个关键词的所有pdf 文件。</p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/20161362">如何用好谷歌等搜索引擎？</a></p>
<h3 id="Chrome浏览器使用"><a href="#Chrome浏览器使用" class="headerlink" title="Chrome浏览器使用"></a>Chrome浏览器使用</h3><h4 id="浏览器快捷键"><a href="#浏览器快捷键" class="headerlink" title="浏览器快捷键"></a>浏览器快捷键</h4><p><img src="http://img.flura.cn/1570719077546.png" alt="1570719077546"></p>
<h4 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h4><p>打开方式有3种： 第一“<strong>按F12</strong>”，第二：s<strong>hift+ctrl+i</strong>，第三： <strong>鼠标右键</strong>  <strong>检查</strong></p>
<p><strong>Console</strong></p>
<p><img src="http://img.flura.cn/11994491-8518ebbd3428c691.webp" alt="11994491-8518ebbd3428c691"></p>
<p><strong>Elements</strong></p>
<p><img src="http://img.flura.cn/11994491-f9287dcb83bb4647.webp" alt="11994491-f9287dcb83bb4647"></p>
<p><img src="http://img.flura.cn/11994491-1e36768a70f6a8cc.webp" alt="11994491-1e36768a70f6a8cc"></p>
<p><strong>Network</strong></p>
<p><img src="http://img.flura.cn/1570714164775.png" alt="1570714164775"></p>
<p> Elements:查找网页源代码HTML中的任一元素,手动修改任一元素的属性和样式且能实时在浏览器里面得到反馈。</p>
<p>Console:记录开发者开发过程中的日志信息，且可以作为与JS进行交互的命令行Shell。</p>
<p>Sources:断点调试JS。</p>
<p>Network:从发起网页页面请求Request后分析HTTP请求后得到的各个请求资源信息（包括状态、资源类型、大小、所用时间等），可以根据这个进行网络性能优化。</p>
<p>Application:记录网站加载的所有资源信息，包括存储数据（Local Storage、Session Storage、IndexedDB、Web SQL、Cookies）、缓存数据、字体、图片、脚本、样式表等。</p>
<p>Security:判断当前网页是否安全。</p>
<p>Audits:对当前网页进行网络利用情况、网页性能方面的诊断，并给出一些优化建议。比如列出所有没有用到的CSS文件等。</p>
<p><strong>Chrome DevTools</strong>(<a target="_blank" rel="noopener" href="https://developers.google.com/web/tools/chrome-devtools">https://developers.google.com/web/tools/chrome-devtools</a>)</p>
<h3 id="常用网站"><a href="#常用网站" class="headerlink" title="常用网站"></a>常用网站</h3><p>GitHub  <a target="_blank" rel="noopener" href="https://github.com/">https://github.com</a></p>
<p>作为开源代码库以及版本控制系统，Github拥有140多万开发者用户。随着越来越多的应用程序转移到了云上，Github已经成为了管理软件开发以及发现已有代码的首选方法。代码托管必备。</p>
<p>MDN  <a target="_blank" rel="noopener" href="https://developer.mozilla.org/">https://developer.mozilla.org</a>   web权威文档</p>
<p>MDN Web Docs 网站提供开放网络（Open Web）技术有关的信息，包括用于网站和渐进式网络应用的 HTML、CSS 和 API。</p>
<h4 id="技术学习网站"><a href="#技术学习网站" class="headerlink" title="技术学习网站"></a>技术学习网站</h4><p><strong>慕课网</strong>（IMOOC）是IT技能学习平台。慕课网(IMOOC)提供了丰富的移动端开发、php开发、web前端、android开发以及html5等视频教程资源公开课。并且富有交互性及趣味性，你还可以和朋友一起编程。  <a target="_blank" rel="noopener" href="https://www.imooc.com/">https://www.imooc.com</a></p>
<p>菜鸟教程 <a target="_blank" rel="noopener" href="http://www.runoob.com/">http://www.runoob.com</a>    入门学习网站</p>
<p>w3school  <a target="_blank" rel="noopener" href="https://www.w3school.com.cn/">https://www.w3school.com.cn</a>   入门学习网站</p>
<h4 id="技术问答"><a href="#技术问答" class="headerlink" title="技术问答"></a>技术问答</h4><p>StackOverFlow技术问答  <a target="_blank" rel="noopener" href="http://stackoverflow.com/">http://stackoverflow.com</a></p>
<p>是一个与程序相关的IT技术问答网站。用户可以在网站免费提交问题，浏览问题，索引相关内容，在创建主页的时候使用简单的HTML</p>
<h4 id="技术博客"><a href="#技术博客" class="headerlink" title="技术博客"></a>技术博客</h4><p>掘金 <a target="_blank" rel="noopener" href="https://juejin.im/">https://juejin.im</a>     思否 <a target="_blank" rel="noopener" href="https://segmentfault.com/">https://segmentfault.com</a>     简书 <a target="_blank" rel="noopener" href="https://www.jianshu.com/">https://www.jianshu.com</a>     csdn(…)</p>
<p>知乎 <a target="_blank" rel="noopener" href="https://zhihu.com/">https://zhihu.com</a> 其实知乎上也有很多不错的技术博客</p>
<p>Chrome插件下载  [扩展迷] <a target="_blank" rel="noopener" href="https://extfans.com/">https://extfans.com/</a></p>
<p><strong>Chrome DevTools</strong> <a target="_blank" rel="noopener" href="https://developers.google.com/web/tools/chrome-devtools/">https://developers.google.com/web/tools/chrome-devtools/</a></p>
<h4 id="github仓库"><a href="#github仓库" class="headerlink" title="github仓库"></a>github仓库</h4><p>在这里再推荐几个github项目: </p>
<p><a target="_blank" rel="noopener" href="https://github.com/ivmm/Student-resources">本文介绍的是利用学生身份可以享受到的相关学生优惠权益</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/kamranahmedse/developer-roadmap">web学习路线</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/justjavac/free-programming-books-zh_CN">免费的计算机编程类中文书籍</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/10/07/webpack4%E4%BB%8E%E9%9B%B6%E9%85%8D%E7%BD%AEreact%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/07/webpack4%E4%BB%8E%E9%9B%B6%E9%85%8D%E7%BD%AEreact%E9%A1%B9%E7%9B%AE/" class="post-title-link" itemprop="url">webpack4从零配置react项目</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-07 10:16:16" itemprop="dateCreated datePublished" datetime="2019-10-07T10:16:16+08:00">2019-10-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-23 23:31:22" itemprop="dateModified" datetime="2021-10-23T23:31:22+08:00">2021-10-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="一、初始化项目文件夹"><a href="#一、初始化项目文件夹" class="headerlink" title="一、初始化项目文件夹"></a>一、初始化项目文件夹</h2><p>在任意目录下，新建一个文件夹作为你的项目文件夹，命名随意。随后使用命令行工具，切换到该文件夹，键入<code>npm init</code>进行初始化（遇到的问题一直回车就好了），初始化完成之后可以看到生成了一个<code>package.json</code>文件。</p>
<p>随后在该项目文件夹下新建两个文件夹：<code>/dist</code>和<code>/src</code>，其中<code>/src</code>用于放置开发的源码，<code>/dist</code>用于放置“编译”后的代码。</p>
<p>随后在<code>/src</code>目录下新建<code>index.html</code>、<code>index.css</code>和<code>index.js</code>文件</p>
<p>按照以下内容创建文件：</p>
<p><strong>index.html</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=&quot;utf-8&quot;/&gt;</span><br><span class="line">        &lt;title&gt;React &amp; Webpack&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=&quot;root&quot;&gt;</span><br><span class="line">            &lt;h1&gt;Hello React &amp; Webpack!&lt;/h1&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>index.css</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background-color: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#root &#123;</span><br><span class="line">    color: white;</span><br><span class="line">    background-color: black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>index.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;./index.css&#x27;;</span><br><span class="line"></span><br><span class="line">console.log(&#x27;Success!&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="二、安装webpack工具"><a href="#二、安装webpack工具" class="headerlink" title="二、安装webpack工具"></a>二、安装webpack工具</h2><p>通过命令行使用webpack 4需要安装两个模块：webpack和webpack-cli，都安装为开发环境依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D webpack webpack-cli</span><br></pre></td></tr></table></figure>

<p>安装完成之后可以看到你的<code>package.json</code>文件发生了变化，在devDependencies属性下多了两个包的属性。</p>
<h2 id="三、配置最基本的webpack"><a href="#三、配置最基本的webpack" class="headerlink" title="三、配置最基本的webpack"></a>三、配置最基本的webpack</h2><ul>
<li><p>1.安装最基本的插件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D html-webpack-plugin clean-webpack-plugin webpack-dev-server css-loader webpack-merge style-loader</span><br></pre></td></tr></table></figure></li>
<li><p>2.在项目文件夹下新建文件<code>webpack.base.conf.js</code>，表示最基本的配置文件，内容如下：</p>
</li>
</ul>
<p>````webpack.base.conf.js`<br>  const path = require(‘path’);<br>  const HtmlWebpackPlugin = require(‘html-webpack-plugin’);<br>  const { CleanWebpackPlugin } = require(‘clean-webpack-plugin’)</p>
<p>  module.exports = {<br>      entry: ‘./src/index.js’,<br>      output: {<br>          filename: ‘bundle.[hash].js’,<br>          path: path.join(__dirname, ‘/dist’)  //打包生成文件地址<br>      },<br>      module: {<br>          rules: [<br>              {<br>                  test: /.css$/,<br>                  use: [‘style-loader’, ‘css-loader’]<br>              }<br>          ]<br>      },<br>      plugins: [<br>          new HtmlWebpackPlugin({<br>              template: ‘./src/index.html’<br>          }),<br>         new CleanWebpackPlugin({<br>              cleanAfterEveryBuildPatterns: [‘./dist’]<br>         })<br>      ]<br>  };</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中，`/src/index.html`是你的网站入口HTML文件，`/src/index.js`是你的入口js文件。</span><br><span class="line"></span><br><span class="line">.在项目文件夹下新建`webpack.dev.conf.js`文件，表示开发环境下的配置。内容如下：</span><br><span class="line"></span><br><span class="line">````webpack.dev.conf.js`</span><br><span class="line">  const merge = require(&#x27;webpack-merge&#x27;);</span><br><span class="line">  const baseConfig = require(&#x27;./webpack.base.conf.js&#x27;);</span><br><span class="line"></span><br><span class="line">  module.exports = merge(baseConfig, &#123;</span><br><span class="line">      mode: &#x27;development&#x27;,</span><br><span class="line">      devtool: &#x27;inline-source-map&#x27;,</span><br><span class="line">      devServer: &#123;</span><br><span class="line">          contentBase: &#x27;./dist&#x27;,</span><br><span class="line">          port: 3000</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>在项目文件夹下新建<code>webpack.prod.conf.js</code>文件，表示生产环境的配置，内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const merge = require(&#x27;webpack-merge&#x27;);</span><br><span class="line">const baseConfig = require(&#x27;./webpack.base.conf.js&#x27;);</span><br><span class="line"></span><br><span class="line">console.log(__dirname);</span><br><span class="line">module.exports = merge(baseConfig, &#123;</span><br><span class="line">    mode: &#x27;production&#x27;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="四、配置npm-scripts"><a href="#四、配置npm-scripts" class="headerlink" title="四、配置npm scripts"></a>四、配置npm scripts</h2><p>配置了三个配置文件以满足两个不同环境下的代码构建，使用语义化较好的<code>npm scripts</code>来构建代码有利于简化工作。</p>
<p>添加新的scripts内容到<code>package.json</code>文件的<code>scripts</code>属性，记得用双引号引起来，其属性如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;start&quot;: &quot;webpack-dev-server --open --config webpack.dev.conf.js&quot;,</span><br><span class="line">        &quot;build&quot;: &quot;webpack --config webpack.prod.conf.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完之后，可以尝试修改<code>/src/index.html</code>、<code>/src/index.js</code>或<code>/src/index.css</code>，运行npm run start命令查看效果。</p>
<p>做到这里，一个基本的开发环境已经搭建出来了。</p>
<h2 id="五、配置Babel"><a href="#五、配置Babel" class="headerlink" title="五、配置Babel"></a>五、配置Babel</h2><p>Babel是一个优秀的JavaScript编译器（这句话源自<a href="https://link.juejin.im/?target=https://babel.bootcss.com/">Babel官网</a>），通过Babel的一些插件，可以将JSX语法、ES6语法转换为ES5的语法，使得低级浏览器也可以运行我们写的代码。</p>
<p>安装 <code>babel-loader</code>，<code>@babel/core</code>，<code>@babel/preset-env</code>，<code>@babel/preset-react</code> 作为 dev 依赖项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-loader@8 @babel/core @babel/preset-env @babel/preset-react -D</span><br></pre></td></tr></table></figure>

<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/babel/babel-loader">babel-loader</a>：使用 Babel 转换 JavaScript依赖关系的 Webpack 加载器</li>
<li><a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-core">@babel/core</a>：即 babel-core，将 ES6 代码转换为 ES5</li>
<li><a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-preset-env">@babel/preset-env</a>：即 babel-preset-env，根据您要支持的浏览器，决定使用哪些 transformations / plugins 和 polyfills，例如为旧浏览器提供现代浏览器的新特性</li>
<li><a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-preset-react">@babel/preset-react</a>：即 babel-preset-react，针对所有 React 插件的 Babel 预设，例如将 JSX 转换为函数</li>
</ul>
<p>**注：babel 7 使用了 <code>@babel</code> 命名空间来区分官方包，因此以前的官方包 babel-xxx 改成了 <code>@babel/xxx</code></p>
<p>修改<code>webpack.base.conf.js</code> 和 创建<code>.babelrc</code> 文件，并配置 babel-loader 及 babel 选项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        exclude: /node_modules/,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: &#x27;babel-loader&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、配置react"><a href="#六、配置react" class="headerlink" title="六、配置react"></a>六、配置react</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react react-dom</span><br></pre></td></tr></table></figure>



<p>在<code>/src</code>中新建一个<code>App.js</code>文件，内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;Hello React &amp; Webpack!&lt;/h1&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].map(name =&gt; &lt;li&gt;&#123;`I&#x27;m $&#123;name&#125;!`&#125;&lt;/li&gt; )</span><br><span class="line">                &#125;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<p>清空<code>index.js</code>之后在其中写入如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;;</span><br><span class="line">import App from &#x27;./App&#x27;;</span><br><span class="line">import &#x27;./index.css&#x27;;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App/&gt;, document.getElementById(&#x27;root&#x27;));</span><br></pre></td></tr></table></figure>

<p>使用<code>npm run start</code>命令打开页面可以看到使用React写出来的效果了。</p>
<p>打开浏览器查看编译后的代码，找到App组件中的map函数这一段，可以发现ES6的语法已经被转换到了ES5的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;].map(function (name) &#123;</span><br><span class="line">    return _react2.default.createElement(</span><br><span class="line">        &#x27;li&#x27;,</span><br><span class="line">        null,</span><br><span class="line">        &#x27;I\&#x27;m &#x27; + name + &#x27;!&#x27;</span><br><span class="line">    );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>箭头函数被写成了function匿名函数。</p>
<h2 id="七、配置TypeScript"><a href="#七、配置TypeScript" class="headerlink" title="七、配置TypeScript"></a>七、配置TypeScript</h2><p>执行以下命令安装 TypeScript compiler 和 loader：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev typescript ts-loader</span><br></pre></td></tr></table></figure>

<p>在根目录新建一个tsconfig.json文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;outDir&quot;: &quot;./dist/&quot;,</span><br><span class="line">    &quot;sourceMap&quot;: true,</span><br><span class="line">    &quot;noImplicitAny&quot;: true,</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,</span><br><span class="line">    &quot;target&quot;: &quot;es6&quot;,</span><br><span class="line">    &quot;jsx&quot;: &quot;react&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;include&quot;: [</span><br><span class="line">    &quot;./src/**/*&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在webpack.dev.conf.js配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#x27;./src/index.js&#x27;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.tsx?$/,</span><br><span class="line">        use: &#x27;ts-loader&#x27;,</span><br><span class="line">        exclude: /node_modules/</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [ &#x27;.tsx&#x27;, &#x27;.ts&#x27;, &#x27;.js&#x27; ]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;bundle.js&#x27;,</span><br><span class="line">    path: path.resolve(__dirname, &#x27;dist&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个时候就可以使用ts了。 ps: 在ts中引用都要申明类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &quot;react&quot;; // 这样没有申明的react会报错、 所以应该npm install @types/react</span><br></pre></td></tr></table></figure>





<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5afc29fa6fb9a07ab379a2ae">基于Webpack搭建React开发环境</a></p>
<p><a target="_blank" rel="noopener" href="https://imweb.io/topic/5b8699a96a0f1b02454de3c0">使用 Webpack 4 和 Babel 7 从头开始创建 React 应用程序</a></p>
<p><a target="_blank" rel="noopener" href="https://webpack.docschina.org/guides/typescript/">TypeScript</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/10/01/%E9%98%BF%E9%87%8C%E4%BA%91%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-OSS-%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E8%84%9A%E6%9C%AC%E4%B8%8A%E4%BC%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/10/01/%E9%98%BF%E9%87%8C%E4%BA%91%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8-OSS-%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%B9%B6%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E8%84%9A%E6%9C%AC%E4%B8%8A%E4%BC%A0/" class="post-title-link" itemprop="url">阿里云对象存储(OSS)部署前端项目并使用自动脚本上传</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-10-01 19:47:31" itemprop="dateCreated datePublished" datetime="2019-10-01T19:47:31+08:00">2019-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-23 23:31:22" itemprop="dateModified" datetime="2021-10-23T23:31:22+08:00">2021-10-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E9%A1%B9/" itemprop="url" rel="index"><span itemprop="name">杂项</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用阿里云OSS + CDN方案的几大好处：</p>
<ul>
<li>成本低廉。OSS+CDN部署自己的网站每个月的花费远比自己买ECS服务器部署网站花费要少得多</li>
<li>大幅降低运维成本。直接使用现成的云服务了，无需花精力去维护ECS了。</li>
<li>极高的可用性。无论阿里云的OSS还是CDN，都已经做好了高可用性，几乎可以保证网站始终可访问</li>
<li>极高的访问速度。ECS带宽毕竟有限的，高带宽意味着超高的费用。但是用OSS+CDN这种天然分布式的架构部署网站很轻松的解决了带宽问题，极大地提升了用户的访问体验。</li>
<li>OSS会自动帮你压缩，使得你的页面加载速度极快。</li>
</ul>
<p>为此我写了一篇博客来帮助指导使用OSS，并且写了一个部署脚本deploy.js来实现自动上传。<a target="_blank" rel="noopener" href="https://github.com/fuchengjx/js_deploy/blob/master/deploy.js"><strong>js_deploy</strong></a></p>
<h2 id="配置-阿里云对象存储-OSS"><a href="#配置-阿里云对象存储-OSS" class="headerlink" title="配置 阿里云对象存储(OSS)"></a>配置 阿里云对象存储(OSS)</h2><p>首先登陆阿里云oss控制台，点击创建一个bucket。</p>
<p><img src="http://img.flura.cn/1569852346504.png" alt="1569852346504"></p>
<p>根据自己的需求选择参数。</p>
<p><img src="http://img.flura.cn/1569852446019.png" alt="配置bucket"></p>
<p>然后就创建了一个bucket。</p>
<p><img src="http://img.flura.cn/1569852577526.png" alt="1569852577526"></p>
<p>为bucket配置域名，在上图中，将阿里云外网访问Bucket域名记录下来。然后在DNS控制台添加记录解析。然后回到oss控制台，在<strong>域名管理</strong>选项 将你刚刚DNS解析的域名 绑定上去。这样就可以通过自己设置的二级域名访问到自己的项目了。</p>
<p><img src="http://img.flura.cn/1569852876717.png" alt="Bucket域名"></p>
<p><img src="http://img.flura.cn/1569853154407.png" alt="DNS控制台解析"></p>
<p><img src="http://img.flura.cn/1569853473577.png" alt="域名管理"></p>
<p>在<strong>基础设置</strong>找到静态页面 设置默认首页的文件名 一般都是index.html，如果有404页面也可以配置。</p>
<p><img src="http://img.flura.cn/1569853929467.png" alt="1569853929467"></p>
<p>就下来就只要将自己的打包出来的静态文件 通过deploy.js脚本上传到OSS上就行了</p>
<h2 id="配置deploy-js"><a href="#配置deploy-js" class="headerlink" title="配置deploy.js"></a>配置deploy.js</h2><p>打开deploy.js将bucket,region填入。key，secret可能忘记(在刚开始使用阿里云的时候，阿里云会将这个发送给你，并提醒你保存)，可以在<strong>用户信息管理</strong> <strong>安全信息管理</strong>获取到自己的Access Key Secret(也可以在这里创建一个新的AccessKey)。 因为deploy.js中保存有你的阿里云accessKeyId与accessKeySecret 所以<strong>记得在.gitignore文件忽略deploy.js</strong></p>
<p><img src="http://img.flura.cn/1569854391813.png" alt="1569854391813"></p>
<p><img src="http://img.flura.cn/1569854935227.png" alt="用户信息管理界面"></p>
<p>这样再稍微配置下要部署的项目 就可以用这个脚本了。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>将deploy.js下载到你的项目根目录下。一般是webpack打包而成的单页面应用。页面打包生成dist文件夹目录，将dist文件夹上传到阿里云oss上。</p>
<p>在package.json中加入这个脚本命令，用来更快的执行部署命令。也可以手动node deploy.js执行部署脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;deploy&quot;: &quot;node deploy.js&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">  &quot;ali-oss&quot;: &quot;^6.1.1&quot;,  // 这是阿里云的oss依赖，也可以直接手动npm install ali-oss --save-dev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>在这里 我演示一个将ant-design-pro构建的项目打包上传到oss上。</p>
<p><img src="http://img.flura.cn/1569923829980.png" alt="上传成功"></p>
<p>然后就可以访问到了(记得一定要在oss控制台设置index.html为首页)</p>
<p><img src="http://img.flura.cn/1569928381648.png" alt="访问成功"></p>
<p>在这里你可以通过访问 <a target="_blank" rel="noopener" href="http://example-oss.flura.cn/">http://example-oss.flura.cn</a>  访问到我的阿里云示例</p>
<h2 id="webpack项目自动部署到阿里云OSS"><a href="#webpack项目自动部署到阿里云OSS" class="headerlink" title="webpack项目自动部署到阿里云OSS"></a>webpack项目自动部署到阿里云OSS</h2><p>这里做一个补充：如果是一个webpack项目 我们使用一个webpack插件，可以实现自动部署到阿里oss的效果。可以极大的提升开发效率，开发完毕，打包项目就可以部署到线上环境。</p>
<h3 id="aliyunoss-webpack-plugin插件使用"><a href="#aliyunoss-webpack-plugin插件使用" class="headerlink" title="aliyunoss-webpack-plugin插件使用"></a><code>aliyunoss-webpack-plugin</code>插件使用</h3><ol>
<li>首先安装<code>aliyunoss-webpack-plugin</code>插件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add aliyunoss-webpack-plugin -D</span><br><span class="line">// 或者使用 npm i aliyunoss-webpack-plugin -D</span><br></pre></td></tr></table></figure>

<ol>
<li>修改<code>webpack.prod.conf.js</code></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const AliyunossWebpackPlugin = require(&#x27;aliyunoss-webpack-plugin&#x27;)</span><br><span class="line">const oss = require(&#x27;../oss&#x27;)</span><br><span class="line">...</span><br><span class="line">plugins: [</span><br><span class="line">    ...</span><br><span class="line">    // 插入到最后面</span><br><span class="line">    new AliyunossWebpackPlugin(&#123;</span><br><span class="line">      buildPath: &#x27;dist/**&#x27;,</span><br><span class="line">      region: oss.region,</span><br><span class="line">      accessKeyId: oss.accessKeyId,</span><br><span class="line">      accessKeySecret: oss.accessKeySecret,</span><br><span class="line">      bucket: oss.bucket,</span><br><span class="line">      deleteAll: true,</span><br><span class="line">      generateObjectPath: function(filename, file) &#123;</span><br><span class="line">        return file.replace(/dist\//, &#x27;&#x27;)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个oss.js 因为不希望 阿里云oss隐私信息被上传到git所以 <strong>记得在.gitignore文件中忽略。</strong></p>
<p>现在只要执行npm run build就能打包并上传到oss上实现自动部署了。</p>
<h2 id="deploy-js-github仓库链接"><a href="#deploy-js-github仓库链接" class="headerlink" title="deploy.js github仓库链接"></a>deploy.js github仓库链接</h2><p><a target="_blank" rel="noopener" href="https://github.com/fuchengjx/js_deploy/blob/master/deploy.js">github仓库</a></p>
<p><a target="_blank" rel="noopener" href="http://example-oss.flura.cn/">部署示例</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://www.flura.cn/2019/09/29/%E5%89%8D%E7%AB%AFgitlab-ci%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="http://img.flura.cn/myAvatar.jpg">
      <meta itemprop="name" content="flura">
      <meta itemprop="description" content="flura的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="flura的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2019/09/29/%E5%89%8D%E7%AB%AFgitlab-ci%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/" class="post-title-link" itemprop="url">前端gitlab-ci实现自动化部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-09-29 10:27:12" itemprop="dateCreated datePublished" datetime="2019-09-29T10:27:12+08:00">2019-09-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-10-23 23:31:22" itemprop="dateModified" datetime="2021-10-23T23:31:22+08:00">2021-10-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本文是我配置一个Gitlab CI实现一个前端项目自动打包部署的踩坑体会。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="为什么要去配置这么一个自动化部署CI，这个需求是什么？"><a href="#为什么要去配置这么一个自动化部署CI，这个需求是什么？" class="headerlink" title="为什么要去配置这么一个自动化部署CI，这个需求是什么？"></a>为什么要去配置这么一个自动化部署CI，这个需求是什么？</h3><p>我所接手的这一个项目是比较老比较大的项目(vue)，它依赖了一些很麻烦的包，这些包很难在window下环境友好运行，所以导致这个项目无法打包部署。这给我们整个团队带来了很大的不便，部署只能用linux很麻烦的手动部署。(学生党不可能人人有钱买Mac吧)，所以我想配置一个gitlab-ci实现项目的自动部署，以提升效率。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="Gitlab"><a href="#Gitlab" class="headerlink" title="Gitlab"></a><strong>Gitlab</strong></h3><p> 一个基于git实现的在线代码仓库软件，你可以用Gitlab自己搭建一个类似于Github一样的系统，一般用于在企业、学校等内部网络搭建Git私服。</p>
<h3 id="什么是持续集成-持续部署（CI-CD"><a href="#什么是持续集成-持续部署（CI-CD" class="headerlink" title="什么是持续集成/持续部署（CI/CD)?"></a>什么是持续集成/持续部署（CI/CD)?</h3><p>阮一峰有篇文章很好的介绍了<a href="https://link.juejin.im/?target=http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html">持续集成是什么？</a></p>
<blockquote>
<p>持续集成指的是，频繁地（一天多次）将代码集成到主干。</p>
</blockquote>
<blockquote>
<p>持续集成的目的，就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。</p>
</blockquote>
<p>通俗易懂的来说就是把 代码测试、打包、发布等工作交给一些工具来自动完成、这样可以提高很多效率，减少失误，开发人员只要关心把代码提交到git就行了。 </p>
<h3 id="Gitlab的CI"><a href="#Gitlab的CI" class="headerlink" title="Gitlab的CI"></a>Gitlab的CI</h3><p>从 GitLab 8.0 开始，GitLab CI 就已经集成在 GitLab 中，我们只要在项目中添加一个 .gitlab-ci.yml 文件，然后添加一个 Runner，即可进行持续集成。 而且随着 GitLab 的升级，GitLab CI 变得越来越强大。</p>
<h3 id="gitlab-ci-yml"><a href="#gitlab-ci-yml" class="headerlink" title=".gitlab-ci.yml"></a>.gitlab-ci.yml</h3><p>在git项目的根目录下的一个文件，记录了一系列的阶段和执行规则。GitLab-CI在push后会解析它，根据里面的内容调用runner来运行。</p>
<p>简单来说就是，你利用Git版本管理Push了本地代码到你的gitlab.com上，然后Gitlab，就通知你的服务器(runner服务器)，也就是Gitlab-runner来运行构建任务。然后跑测试用例，测试用例通过了就生成Build出相应的环境的代码，自动部署上不同的环境服务器上面去。</p>
<h3 id="GitLab-Runner"><a href="#GitLab-Runner" class="headerlink" title="GitLab-Runner"></a>GitLab-Runner</h3><p>这个是脚本执行的承载者，.gitlab-ci.yml的script部分的运行就是由runner来负责的。GitLab-CI浏览过项目里的.gitlab-ci.yml文件之后，根据里面的规则，分配到各个Runner来运行相应的脚本script。这些脚本有的是测试项目用的，有的是部署用的。</p>
<p><img src="http://img.flura.cn/1569760156912.png" alt="1569760156912"></p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>简而言之，CI所需要的步骤可以归结为：</p>
<ol>
<li><p>添加<code>.gitlab-ci.yml</code>到项目的根目录</p>
</li>
<li><p>配置一个Runner</p>
</li>
</ol>
<p>从此刻开始，在每一次push到Git仓库的过程中，Runner会自动开启pipline，pipline将显示在项目的Pipline页面中。</p>
<hr>
<p>本指南要求：</p>
<ul>
<li>使用版本8.0+ 的GitLab实例或者是使用<a target="_blank" rel="noopener" href="https://gitlab.com/">GitLab.com</a></li>
<li>一个想使用GitLab CI的项目</li>
</ul>
<h3 id="配置-gitlab-ci-yml"><a href="#配置-gitlab-ci-yml" class="headerlink" title="配置.gitlab-ci.yml"></a>配置<code>.gitlab-ci.yml</code></h3><ol>
<li><p>在项目的根目录创建一个名为<code>.gitlab-ci.yml</code>的文件。注意：<code>.gitlab-ci.yml</code>是一个*&amp;####&amp;<em><em>10</em></em>&amp;####&amp;*文件，所以必须要格外注意锁紧。使用空格，而不是tabs。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">image: node  # 选用docker镜像</span><br><span class="line"></span><br><span class="line">stages: # Stages 表示构建阶段，这里有两个阶段 install, deploy</span><br><span class="line">- install</span><br><span class="line">- deploy</span><br><span class="line"></span><br><span class="line">install-staging:dep: # Jobs 表示构建工作，表示某个 Stage 里面执行的工作。</span><br><span class="line">  stage: install</span><br><span class="line">  only: # 定义了只有在被merge到了master分支上 才会执行部署脚本。</span><br><span class="line">  - master</span><br><span class="line">  script:</span><br><span class="line">  - echo &quot;=====start install======&quot;</span><br><span class="line">  - npm install --registry=https://registry.npm.taobao.org  #安装依赖</span><br><span class="line">  - echo &quot;=====end install======&quot;</span><br><span class="line">  artifacts:  # 将这个job生成的依赖传递给下一个job。需要设置dependencies</span><br><span class="line">    expire_in: 60 mins   # artifacets 的过期时间，因为这些数据都是直接保存在 Gitlab 机器上的，过于久远的资源就可以删除掉了</span><br><span class="line">    paths:  # 需要被传递给下一个job的目录。</span><br><span class="line">    - node_modules/</span><br><span class="line">    </span><br><span class="line">deploy-staging:dep:</span><br><span class="line">  stage: deploy</span><br><span class="line">  only:</span><br><span class="line">  - master</span><br><span class="line">  script:</span><br><span class="line">  - echo &quot;=====start build======&quot;</span><br><span class="line">  - npm run build  # 将项目打包</span><br><span class="line">  - echo &quot;=====end build======&quot;</span><br><span class="line">  - echo &quot;=====start deploy======&quot;</span><br><span class="line">  - npm run deploy # 此处执行部署脚本，将打包好的静态文件上传到阿里云的oss上，为了保护项目安全，使抽象成deploy步骤。</span><br><span class="line">  - echo &quot;=====end deploy!!!!!!======&quot;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这是我的**<code>.gitlab-ci.yml</code>脚本**。(# 为<code>.gitlab-ci.yml</code>脚本注释)</p>
<h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image: node  # 选用docker镜像</span><br></pre></td></tr></table></figure>

<pre><code>我项目的 CI 任务是选的在 Docker 上运行，所以每次执行 CI 任务的时候，都会新启动一个 Docker 容器。因     为是前端项目，所以需要node环境。所以选用的是node镜像。也可以选择自己的docker镜像。
</code></pre>
<h4 id="stages"><a href="#stages" class="headerlink" title="stages"></a>stages</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stages: # Stages 表示构建阶段，这里有两个阶段 install, deploy</span><br><span class="line">- install</span><br><span class="line">- deploy</span><br></pre></td></tr></table></figure>

<p>   Stages 表示构建阶段，说白了就是上面提到的流程。 我们可以在一次 Pipeline 中定义多个 Stages，每个Stage可以完成不同的任务。 Stages有下面的特点：</p>
<ul>
<li><p>所有 Stages 会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始</p>
</li>
<li><p>只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功</p>
</li>
<li><p>如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败</p>
</li>
</ul>
<h4 id="only"><a href="#only" class="headerlink" title="only"></a>only</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">only:</span><br><span class="line">- master</span><br></pre></td></tr></table></figure>

<p>只有maser分支才会触发这个脚本，因为我们采用的git-flow工作流，开发人员可能把自己未完善的分支(没有经过上级code review)提交到线上仓库，那么只要有push就会触发部署到线上环境，这样的后果是不堪设想的，所以必须加一个only，只有经过了code review的代码 被merge进入了maser分支才会实现部署到线上环境。</p>
<h4 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install-staging:dep: # Jobs 表示构建工作，表示某个 Stage 里面执行的工作。</span><br><span class="line">  stage: install</span><br></pre></td></tr></table></figure>

<p>   Jobs 表示构建工作，表示某个 Stage 里面执行的工作。 我们可以在 Stages 里面定义多个 Jobs，这些 Jobs 会有以下特点：</p>
<ul>
<li><p>相同 Stage 中的 Jobs 会并行执行</p>
</li>
<li><p>相同 Stage 中的 Jobs 都执行成功时，该 Stage 才会成功</p>
</li>
<li><p>如果任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 失败</p>
</li>
</ul>
<h4 id="script"><a href="#script" class="headerlink" title="script"></a>script</h4>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">script:</span><br><span class="line"> - echo &quot;=====start install======&quot;</span><br><span class="line"> - npm install --registry=https://registry.npm.taobao.org</span><br><span class="line"> - echo &quot;=====end install======&quot;</span><br></pre></td></tr></table></figure>

<p>   <strong>script</strong>是一段由Runner执行的shell脚本</p>
<h4 id="artifact"><a href="#artifact" class="headerlink" title="artifact"></a>artifact</h4> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">artifacts:  # 将这个job生成的依赖传递给下一个job。需要设置dependencies</span><br><span class="line">  expire_in: 60 mins   # artifacets 的过期时间，因为这些数据都是直接保存在 Gitlab 机器上的，过于久远的资源就可以删除掉了</span><br><span class="line">  paths:</span><br><span class="line">  - node_modules/</span><br></pre></td></tr></table></figure>

<p>   artifacts 被用于在job作业成功后将制定列表里的文件或文件夹附加到job上，传递给下一个job，如果要在两个job之间传递artifacts，你必须设置<a target="_blank" rel="noopener" href="https://docs.gitlab.com/ce/ci/yaml/README.html#dependencies">dependencies</a></p>
<h4 id="脚本总结"><a href="#脚本总结" class="headerlink" title="脚本总结"></a>脚本总结</h4><p><strong>总结</strong>： 这个脚本的作用是 将merge进入master分支的代码打包并部署到阿里云的oss上。这里最值得注意的就是artifact，因为定义了两个job，其实每个job都是用的新的镜像，所以这样就会导致install阶段与deploy阶段没有任何关系，但是实际上deploy阶段是依赖install阶段安装的node_module的。所以必须将install阶段安装的 node_modules传递给下一个job(deploy)，这就需要用到artifact或者cache了(这里我用的是artifact)。ps:我还其实还把这两个job整合成一个了，但是不知道为什么明明两个分开执行就只要10min，而合在一个job就要超过1h，最后导致超时Pipeline失败。</p>
<p>更多详细配置可以看这篇博客<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000011890710">gitlab-ci配置详解</a></p>
<p>或者参考官方文档 <a target="_blank" rel="noopener" href="https://docs.gitlab.com/ee/ci/yaml/README.html">官方配置文档</a></p>
<ol start="2">
<li><p>推送<code>.gitlab-ci.yml</code>到GitLab</p>
<p>一旦创建了<code>.gitlab-ci.yml</code>，你应该及时添加到Git仓库并推送到GitLab。</p>
<p>现在到<strong>Pipelines</strong>页面查看，将会看到该Pipline处于等待状态。</p>
<p><img src="http://img.flura.cn/1569815810780.png" alt="1569815810780"></p>
</li>
</ol>
<h3 id="配置Runner"><a href="#配置Runner" class="headerlink" title="配置Runner"></a>配置Runner</h3><p>在GitLab中，Runners将会运行你在<code>.gitlab-ci.yml</code>中定义的jobs。Runner可以是虚拟机，VPS，裸机，docker容器，甚至一堆容器。GitLab和Runners通过API通信，所以唯一的要求就是运行Runners的机器可以联网。</p>
<p>一个Runner可以服务GitLab中的某个特定的项目或者是多个项目。如果它服务所有的项目，则被称为共享的Runner。</p>
<p>在<a target="_blank" rel="noopener" href="https://docs.gitlab.com/ee/ci/runners/README.html">Runners</a>文档中查阅更多关于不同Runners的信息。</p>
<p>你可以通过<strong>Settings-&gt;CI/CD</strong>查找是否有Runners分配到你的项目中。创建一个Runner是简单且直接的。官方支持的Runner是用GO语言写的，它的文档在这里<a target="_blank" rel="noopener" href="https://docs.gitlab.com/runner/%E3%80%82">https://docs.gitlab.com/runner/。</a></p>
<p>为了有一个功能性的Runner，你需要遵循以下步骤：</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a><a target="_blank" rel="noopener" href="https://docs.gitlab.com/runner/install/">安装</a></h4><ol>
<li><p>添加Gitlab的官方源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># For Debian/Ubuntu</span><br><span class="line">curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.deb.sh | sudo bash</span><br><span class="line"></span><br><span class="line"># For CentOS</span><br><span class="line">curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.rpm.sh | sudo bash</span><br></pre></td></tr></table></figure></li>
<li><p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># For Debian/Ubuntu</span><br><span class="line">sudo apt-get install gitlab-ci-multi-runner</span><br><span class="line"></span><br><span class="line"># For CentOS</span><br><span class="line">sudo yum install gitlab-ci-multi-runner</span><br></pre></td></tr></table></figure></li>
<li><p>注册Runner<br>Runner需要注册到Gitlab才可以被项目所使用，一个gitlab-ci-multi-runner服务可以注册多个Runner。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gitlab-ci-multi-runner register</span><br><span class="line"></span><br><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )</span><br><span class="line">https://mygitlab.com/ci</span><br><span class="line">Please enter the gitlab-ci token for this runner</span><br><span class="line">xxx-xxx-xxx</span><br><span class="line">Please enter the gitlab-ci description for this runner</span><br><span class="line">my-runner</span><br><span class="line">INFO[0034] fcf5c619 Registering runner... succeeded</span><br><span class="line">Please enter the executor: shell, docker, docker-ssh, ssh?</span><br><span class="line">Please enter the Docker image (eg. ruby:2.1):</span><br><span class="line">node</span><br><span class="line">INFO[0037] Runner registered successfully. Feel free to start it, but if it&#x27;s</span><br><span class="line">running already the config should be automatically reloaded!</span><br></pre></td></tr></table></figure></li>
</ol>
<p>ps: 这里面的gitlab-ci coordinator URL 与token</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )</span><br><span class="line">https://mygitlab.com/ci</span><br><span class="line">Please enter the gitlab-ci token for this runner</span><br><span class="line">xxx-xxx-xxx</span><br></pre></td></tr></table></figure>

<p>是在gitlab配置对应的runner里可以查看的。</p>
<p><img src="http://img.flura.cn/1569816937998.png" alt="1569816937998"></p>
<p><img src="http://img.flura.cn/1569817315527.png" alt="1569817315527"></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a><a target="_blank" rel="noopener" href="https://docs.gitlab.com/ee/ci/runners/README.html#registering-a-specific-runner">配置</a></h4><p>按照上面的连接设置你自己的Runner，我这边因为这是专用对于一个项目的runner，所以我配置的是specific runner。</p>
<p>一旦Runner安装好，你可以从项目的<strong>Settings-&gt;CI/CD</strong>找到Runner页面。</p>
<p><img src="http://img.flura.cn/1569816937998.png" alt="1569816937998"></p>
<p><img src="http://img.flura.cn/1569817028804.png" alt="1569817028804"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a target="_blank" rel="noopener" href="http://www.ttlsa.com/auto/gitlab-cicd-quick-start/">GitLab CI/CD快速入门</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5c015f4ae51d453244120d86">前端项目基于GitLab-CI的持续集成/持续部署（CI/CD）</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5b03963a51882542821ca56a">前端的gitlab的ci初尝试</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://docs.gitlab.com/ee/ci/yaml/README.html"><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000007180257">GitLab-CI 从安装到差点放弃</a></a></p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="flura"
      src="http://img.flura.cn/myAvatar.jpg">
  <p class="site-author-name" itemprop="name">flura</p>
  <div class="site-description" itemprop="description">flura的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">赣ICP备18002942号 </a>
  </div>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">flura</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
